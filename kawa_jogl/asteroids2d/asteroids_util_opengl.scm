(require <asteroids_util_general>)
(require <asteroids_util_math>)

(with-all-forms-exported

(define-alias GL2 javax.media.opengl.GL2)
(define-alias KeyEvent java.awt.event.KeyEvent)
(define-alias FloatBuffer java.nio.FloatBuffer)
(define-constant newDirectFloatBuffer com.jogamp.common.nio.Buffers:newDirectFloatBuffer)

(define-simple-class vertex ()
    (x::double 0) (y::double 0) (z::double 0)
    (r::double 0) (g::double 0) (b::double 0)
    ((*init*) #!void)
    ((*init* ix::double iy::double)
        (set! x ix)
        (set! y iy)
    )
    ((toString)::String (String:format "#<xyz(%f, %f, %f), rgb(%f, %f, %f)>" x y z r g b))
)

(define-simple-class polygon ()
    (verts::ArrayList[vertex] (ArrayList))
    ((*init*) #!void)
    ((*init* vertices::ArrayList[vertex]) (set! verts vertices))
)

;(define-simple-class polar-vertex ()
;    (m::double 0) (t::double 0)
;    ((*init*) #!void)
;    ((*init* im::double it::double)
;        (set! m im)
;        (set! t it)
;    )
;    ((toString)::String (String:format "p(%f, %f)" m t))
;)

; returns a list of vertices of a "regular" polygon, with the first vertex at rot radians
; the radius parameter is a function to allow non-regular polygons such as isosceles triangles
(define (calc-poly rot::double radiusf::gnu.mapping.Procedure sides::int colorf::gnu.mapping.Procedure)
    (returning (poly (polygon)) (pascal-for (i 0 sides 1)
        (let* ((rad::double (radiusf i))
               (ang::double (+ rot (* tau (/ i sides))))
            )
            (let-values (((r g b) (colorf i)))
                (invoke poly:verts 'add (returning (v (vertex))
                    (set!* (v:x v:y v:z) ((* rad (cos ang)) (* rad (sin ang)) 0))
                    (set!* (v:r v:g v:b) (r g b))
                ))
            )
        )
    ))
)

; check if point (px, py) is on the "inside" of a line (calc-poly draws lines counter-clockwise)
(define (inside-line? px py x1 y1 x2 y2)
    (let* ((theta1 (ensure-proper-angle (atan2 (- y2 y1) (- x2 x1))))
           (theta2 (ensure-proper-angle (atan2 (- py y1) (- px x1))))
           (dtheta (ensure-proper-angle (- theta2 theta1))))
        (< 0 dtheta (/ tau 2))
;        (printf "(%s, %s)\n(%s, %s)\n(%s, %s)\n" px py x1 y1 x2 y2)
;        (printf "theta1 %s; theta2: %s; dtheta: %s\n" (rad->deg theta1) (rad->deg theta2) (rad->deg dtheta))
;        (returning (val (or (< 0 dtheta (/ tau 2))))
;            (printf "returning %s from 'inside-line?\n" val)
;        )
    )
)

(define (inside-poly? buf::FloatBuffer vertidx ox oy rot px py)
    (let* ((offset (car vertidx))
           (numverts (cdr vertidx))
           (matmultres (untranslate/rotate ox oy rot px py))
           (nx (matmultres 0)) (ny (matmultres 1))
          )
        (buf:position (* offset 6))
        ;(printf "checking if (%s, %s) is inside asteroid at (%s, %s)\n" px py ox oy)
        (define firstx (buf:get))
        (define firsty (buf:get))
        (let loop ((oldx firstx) (oldy firsty) (i 0))
            (if (< i numverts)
                (begin
                    (define newpos (+ (buf:position) 4))
                    ;(printf "newpos: %s\n" newpos)
                    (buf:position newpos) ;skip z, r, g, b, this may need to be modified to include z during the transition to 3d
                    ;(printf "bufpos %s\n" (buf:position))
                    (define newx (if (= (+ i 1) numverts) firstx (buf:get)))
                    (define newy (if (= (+ i 1) numverts) firsty (buf:get)))
                    (if (inside-line? nx ny oldx oldy newx newy)
                        (loop newx newy (+ i 1))
                        #f
                    )
                )
                #t
            )
        )
    )
)

(define-macro (with-overlapping-slices slicename source groupsize overlap . body)
    (define-gensyms loop idx backamt)
    `(let ((,backamt (if (>= ,overlap ,groupsize) (- ,groupsize 1) ,overlap)))
        (let ,loop ((,slicename ::ArrayList (ArrayList)) (,idx 0))
        ;(printf "idx: %s; overlap: %s; backamt: %s; groupsize: %s\n" ,idx ,overlap ,backamt ,groupsize)
        (cond
            ((>= (invoke ,slicename 'size) ,groupsize)
                ,@body
                (,loop (ArrayList) (- ,idx ,backamt))
            )
            ((not (>= ,idx (invoke ,source 'size)))
                (invoke ,slicename 'add (invoke ,source 'get ,idx))
                (,loop ,slicename (+ ,idx 1))
            )
        )
    ))
)

(define (divide-poly poly::polygon)
    (returning (polys::ArrayList[polygon] (ArrayList))
    (let* ((verts poly:verts)
           (size (ceiling (+ (/ (verts:size) 2) .5))))
        (with-overlapping-slices vertslice verts size 2
            ;(printf "%s %s\n" (verts:size) (vertslice:size))
            (if (>= (vertslice:size) 3)
                (polys:add (polygon vertslice))
            )
        )
    ))
)

(define (append-polygon-to-buffer old-buffer::FloatBuffer poly::polygon)
    (let* ((old-capacity (old-buffer:capacity))
           (floats-per-vertex 6)
           (old-vertcount (/ old-capacity floats-per-vertex))
           (sides (invoke poly:verts 'size))
           (total-new-floats::int (+ old-capacity (* floats-per-vertex sides)))
           (new-buffer (newDirectFloatBuffer total-new-floats))
        )
        (old-buffer:rewind)
        (new-buffer:put old-buffer)
        (java-iterate poly:verts (v vertex)
            (new-buffer:put v:x)
            (new-buffer:put v:y)
            (new-buffer:put v:z)

            (new-buffer:put v:r)
            (new-buffer:put v:g)
            (new-buffer:put v:b)
        )
        ; return the new buffer, and an (offset, size) pair for glDrawArrays to use for the new poly
        (values new-buffer (cons old-vertcount sides))
    )
)

(define *polygons-buffer* ::FloatBuffer (newDirectFloatBuffer 0))
(define (append-polygon-to-global-buffer poly::polygon)
    (let-values (((buf ind) (append-polygon-to-buffer *polygons-buffer* poly)))
        (set! *polygons-buffer* buf)
        ind
    )
)

(define *vbo-pointers* ::int[] (int[] length: 1))

(define (set-polygons-buffer gl2::GL2)
;    (*polygons-buffer*:rewind)
;    (gl2:glVertexPointer 3 gl2:GL_FLOAT 0 *polygons-buffer*)
    (gl2:glGenBuffers 1 *vbo-pointers* 0)
    (gl2:glBindBuffer gl2:GL_ARRAY_BUFFER (*vbo-pointers* 0))
    (*polygons-buffer*:rewind)
;    (let ((tmp (float[] length: (*polygons-buffer*:capacity))))
;        (*polygons-buffer*:get tmp)
;        (display tmp) (newline)
;        (display tmp:length) (newline)
;    )
    (*polygons-buffer*:rewind)
    ; the multiplication by 4 is because glBufferData takes a size in bytes
    (gl2:glBufferData gl2:GL_ARRAY_BUFFER (* (*polygons-buffer*:capacity) 4) *polygons-buffer* gl2:GL_DYNAMIC_DRAW)
)

(define (shader-compiled? gl2::GL2 shader-id)
    (define tmp (int[] 0))
    (gl2:glGetShaderiv shader-id gl2:GL_COMPILE_STATUS tmp 0)
    (if (= (tmp 0) 0) #f #t)
)

(define (print-shader-info-log gl2::GL2 id::int)
    (define returned-size (int[] 0))
    (define len (let ((tmp (int[] 0))) (gl2:glGetShaderiv id gl2:GL_INFO_LOG_LENGTH tmp 0) (tmp 0)))
    (define data (byte[] length: len))
    (gl2:glGetShaderInfoLog id len returned-size 0 data 0)
    (if (> (returned-size 0) 0) (printf "ShaderInfoLog for shader %d: %s\n\n" id (String data)))
)

(define (glShaderSource gl2::GL2 id::int src::String)
    (gl2:glShaderSource id 1 (String[] src) (int[] (src:length)) 0)
)

(define (compile-shader gl2::GL2 type::int source::String)
    (returning (shader-id (gl2:glCreateShader type))
        ;(printf "shader source:\n%s\n\n" source)
        (glShaderSource gl2 shader-id source)
        (gl2:glCompileShader shader-id)
        (when (not (shader-compiled? gl2 shader-id))
            (print-shader-info-log gl2 shader-id)
            (error "Failed to compile shader.")
        )
    )
)

(define (make-shader-program gl2::GL2 vertex-source::String fragment-source::String)
    (returning (shader-program (gl2:glCreateProgram))
        (gl2:glAttachShader shader-program (compile-shader gl2 gl2:GL_VERTEX_SHADER vertex-source))
        (gl2:glAttachShader shader-program (compile-shader gl2 gl2:GL_FRAGMENT_SHADER fragment-source))
        (gl2:glLinkProgram shader-program)
    )
)

(define-alias PMVMatrix com.jogamp.opengl.util.PMVMatrix)
(define (getPMVMatrix gl2::GL2)
    (returning (mtrx (PMVMatrix))
        (define tmp (float[] length: 16))
        (gl2:glGetFloatv gl2:GL_MODELVIEW_MATRIX tmp 0)
        (gl2:glMatrixMode gl2:GL_MODELVIEW_MATRIX)
        (mtrx:glMatrixMode gl2:GL_MODELVIEW)
        (mtrx:glLoadMatrixf tmp 0)
        (gl2:glGetFloatv gl2:GL_PROJECTION_MATRIX tmp 0)
        (gl2:glMatrixMode gl2:GL_PROJECTION_MATRIX)
        (mtrx:glMatrixMode gl2:GL_PROJECTION)
        (mtrx:glLoadMatrixf tmp 0)
    )
)

(define (untranslate/rotate ox oy rot px py)
    (define mtrx (PMVMatrix))
    (mtrx:glMatrixMode GL2:GL_MODELVIEW)
    (mtrx:glLoadIdentity)
    (mtrx:glTranslatef ox oy 0)
    (mtrx:glRotatef (rad->deg rot) 0 0 1)
    (define mvi-mtrx (mtrx:glGetMviMatrixf))
    (define m1 (float[] length: 16))
    (mtrx:update)
    (mvi-mtrx:reset)
    (mvi-mtrx:get m1)
    (define m2 (float[] px py 0 1))
    ((ct-matrix-mult 4 4 1 float) m1 m2)
)

(define (drawPolygon gl2::GL2 x y rot vertidx)
    (gl2:glMatrixMode gl2:GL_MODELVIEW)
    (gl2:glPushMatrix)
    (gl2:glTranslated x y 0)
    (gl2:glRotated (rad->deg rot) 0 0 1)
    (gl2:glDrawArrays gl2:GL_POLYGON (car vertidx) (cdr vertidx))
    (gl2:glPopMatrix)
)

(define (draw-dotted-line gl2 dot x1 y1 x2 y2)
    (let* ( (density 20)
            (dx (- x2 x1))
            (dy (- y2 y1))
            (dist (java.lang.Math:sqrt (+ (* dx dx) (* dy dy))))
            (slope (atan2 dy dx))
          )
        (pascal-for (i 0 density 1)
            (define j (/ i density))
            (drawPolygon gl2 (+ x1 (* j dist (cos slope))) (+ y1 (* j dist (sin slope))) 0 dot)
        )
    )
)
) ; end of with-all-forms-exported
