(require <asteroids_util>)

(define-constant +screen-width+ 640)
(define-constant +screen-height+ 480)

; the real values are double this, since these are used as plus/minus
(define-constant +logical-width+ 4)
(define-constant +logical-height+ 4)
(define-constant +viewport-width+ 2)
(define-constant +viewport-height+ 2)

(define-simple-class drawer () interface: #t
    ((draw gl2::GL2) #!abstract)
)

(define-constant +shot-color+ '(1 1 1))
(define-constant +shot-speed+ .1)
(define-constant +shot-size+ .01)
(define-constant +shot-duration+ 45)
(define-constant +shot-vertidx+ (append-polygon-to-global-buffer (calc-poly 0 (constantly +shot-size+) 10 (constantly (apply values +shot-color+)))))

(define-simple-class shot (drawer)
    (x::double 0) (y::double 0)
    (rot::double 0)
    (velocity::double 0)
    (frames-until-decay::int +shot-duration+)
    ((*init* ix iy irot ivel)
        (set! x ix)
        (set! y iy)
        (set! rot irot)
        (set! velocity (+ ivel +shot-speed+)) ; shots start off with the ship's velocity added to the constant
    )
    ((updatePosition!)
        (inc! frames-until-decay -1)
        (set-values! (x y) (apply-polar-movement x y velocity rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((expired?) (< frames-until-decay 0))
    ((draw gl2) (drawPolygon gl2 x y rot +shot-vertidx+))
)

(define-constant +frames-between-shots+ 5)
(define-constant +min-ship-speed+ -0.09)
(define-constant +max-ship-speed+ 0.10)
(define *active-shots*::ArrayList[shot] (ArrayList))

(define-simple-class ship (drawer)
    (x::double 0) (y::double 0)
    (rot::double (/ tau 4))
    (velocity::double 0)
    (size .1)
    (color '(1 .5 0))
    (shooting-cooldown::int 0) ; in frames for now, probably should make more robust by handling milliseconds
    ((*init*) (recalcVerts!) (set! rot (/ tau 4)))
    (vertidx)
    ((recalcVerts!) (set! vertidx (append-polygon-to-global-buffer (calc-poly 0 (lambda (i) (if (= i 0) (* 2 size) size)) 3 (constantly (apply values color)))))) ; isosceles triangle
    ((rotate delta::double) (inc! rot delta))
    ((getVertidx) vertidx)
    ((updatePosition!)
        (if (> shooting-cooldown 0) (inc! shooting-cooldown -1))
        (set-values! (x y) (apply-polar-movement x y velocity rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((draw gl2) (drawPolygon gl2 x y rot vertidx))
    ((shoot)
        (*active-shots*:add (shot x y rot velocity))
        (set! shooting-cooldown +frames-between-shots+)
    )
)

(define-constant +min-asteroid-size+ .1)
(define-constant +max-asteroid-size+ .5)
(define-constant +min-asteroid-ivel+ .01)
(define-constant +max-asteroid-ivel+ .05)

(define-simple-class asteroid (drawer)
    (x::double (random-range (- +logical-width+) +logical-width+))
    (y::double (random-range (- +logical-height+) +logical-height+))
    (rot::double (random tau))
    (velocity::double (random-range +min-asteroid-ivel+ +max-asteroid-ivel+))
    (size (random-range +min-asteroid-size+ +max-asteroid-size+))
    (color (list (random-range .25 .65) 0 0))
    (vertidx #!null)
    (children::ArrayList[asteroid] #!null)
    ((constructor-helper poly::polygon) access: 'private
        (set! vertidx (append-polygon-to-global-buffer poly))
        (set! children (ArrayList-map asteroid (divide-poly poly)))
    )
    ((*init*)
        (constructor-helper (calc-poly (random tau) (constantly size) (random-range 3 9) (constantly (apply values color))))
    )
    ((*init* poly::polygon) (constructor-helper poly))

    ((draw gl2) (drawPolygon gl2 x y rot vertidx))
    ((updatePosition!)
        (set-values! (x y) (apply-polar-movement x y velocity rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((split)
        (printf "splitting asteroid at (%f, %f), %d children\n" x y (children:size))
        (java-iterate children c
            (set!* (c:x c:y) (x y))
            (*active-asteroids*:add c)
        )
    )
)

(define *active-asteroids*::ArrayList[asteroid] (ArrayList))
(pascal-for (i 0 10 1) (*active-asteroids*:add (asteroid)))

(define player-ship (ship))

(define jf (javax.swing.JFrame))
(jf:setSize +screen-width+ +screen-height+)
(jf:setResizable #f)
(jf:setDefaultCloseOperation javax.swing.JFrame:EXIT_ON_CLOSE)
(define glcanv (javax.media.opengl.awt.GLCanvas))

(define *currently-held-keys* (java.util.HashSet))
(define-constant +rotation-delta+ (/ tau 64))
(define-constant +velocity-delta+ .01)
(define (event-loop)
    (define-macro (key-held? key) `(*currently-held-keys*:contains (static-field KeyEvent ,key)))
    (if (key-held? 'VK_LEFT) (player-ship:rotate +rotation-delta+))
    (if (key-held? 'VK_RIGHT) (player-ship:rotate (- +rotation-delta+)))
    (if (key-held? 'VK_UP) (inc! player-ship:velocity +velocity-delta+))
    (if (key-held? 'VK_DOWN) (inc! player-ship:velocity (- +velocity-delta+)))
    (inplace! (clamp +min-ship-speed+ +max-ship-speed+) player-ship:velocity)
    (if (and (key-held? 'VK_SPACE) (= player-ship:shooting-cooldown 0)) (player-ship:shoot))
    (player-ship:updatePosition!)
    (java-iterate *active-shots* (s shot iter)
        (s:updatePosition!)
        (if (s:expired?) (iter:remove))
    )
    (java-iterate *active-asteroids* (a asteroid)
        (a:updatePosition!)
    )
    ;(printf "pos: %s, %s\n" player-ship:x player-ship:y)
)

(define-constant +background-intensity+ .5)


(define-constant background (append-polygon-to-global-buffer (calc-poly
    (/ tau 8) (constantly (sqrt (* 2 (square +logical-width+)))) 4
    (lambda (i) (case i
        ((0) (values +background-intensity+ +background-intensity+ 0))
        ((1) (values +background-intensity+ 0 0))
        ((2) (values 0 +background-intensity+ +background-intensity+))
        ((3) (values 0 +background-intensity+ 0))
    ))
)))

(define (draw-background gl2::GL2)
    (drawPolygon gl2 0 0 0 background)
)

(define *main-window-matrix* #!null)

(define (render gl2::GL2)
    (event-loop) ; might be a good idea to move this out of render later
    (gl2:glClear gl2:GL_COLOR_BUFFER_BIT)
    (define-constant (set-projection gl2::GL2 width::double height::double)
        (gl2:glMatrixMode gl2:GL_PROJECTION)
        (gl2:glLoadIdentity)
        (gl2:glOrtho (- width) width 
                     (- height) height
                     1 -1)
;        (define proj-matrix (int[] length: 16))
;        (gl2:glGetIntegerv gl2:GL_PROJECTION_MATRIX proj-matrix 0)
;        (display proj-matrix) (newline)
    )
    (define-constant (prepare-frame gl2::GL2 cx cy ox oy) ; center and offset
        (gl2:glMatrixMode gl2:GL_MODELVIEW)
        (gl2:glLoadIdentity)
        (gl2:glTranslated (- cx) (- cy) 0)
        (gl2:glTranslated (- ox) (- oy) 0)
    )
    (define-constant (draw-foreground gl2)
        (player-ship:draw gl2)
        (java-iterate *active-shots* (s shot) (s:draw gl2))
        (java-iterate *active-asteroids* (a asteroid) (a:draw gl2))
    )
    (define-constant (draw-frame gl2 cx cy ox oy)
        (prepare-frame gl2 cx cy ox oy)
        (draw-background gl2)
        (draw-foreground gl2)
    )
    (set-projection gl2 +logical-width+ +logical-height+)
    ;(set-projection gl2 (* 2 +logical-width+) (* 2 +logical-height+))
    (gl2:glViewport 0 0 640 480)
    (draw-frame gl2 0 0 0 0)
    (if (equal? *main-window-matrix* #!null) (set! *main-window-matrix* (getPMVMatrix gl2)))
    (set-projection gl2 +viewport-width+ +viewport-height+)
    (gl2:glViewport 0 0 320 240)
    ; display 4 copies (in positions based on the quadrant of the ship) to ensure that objects on the wrapped sides appear properly
    (define min-x (if (> player-ship:x 0) -1 0))
    (define max-x (+ (if (> player-ship:x 0) 0 1) 1))
    (define min-y (if (> player-ship:y 0) -1 0))
    (define max-y (+ (if (> player-ship:y 0) 0 1) 1))
    ;(printf "(%s, %s) -> (%s, %s), (%s, %s)\n" player-ship:x player-ship:y min-x min-y max-x max-y)
    (pascal-for (i min-x max-x 1) (pascal-for (j min-y max-y 1)
        (let ((ox (* 2 i +logical-width+)) (oy (* 2 j +logical-height+)))
            (prepare-frame gl2 player-ship:x player-ship:y ox oy)
            (draw-background gl2)
        )
    ))
    (pascal-for (i min-x max-x 1) (pascal-for (j min-y max-y 1)
        (let ((ox (* 2 i +logical-width+)) (oy (* 2 j +logical-height+)))
            (prepare-frame gl2 player-ship:x player-ship:y ox oy)
            (draw-foreground gl2)
        )
    ))
)

(define *shader-program* ::int 0)

(glcanv:addGLEventListener (object (javax.media.opengl.GLEventListener)
    ((*init*) #!void)
    ((display drawable) (render ((drawable:getGL):getGL2)))
    ((init drawable)
        (let ((gl (javax.media.opengl.DebugGL2 ((drawable:getGL):getGL2))))
            ;(gl:glEnableClientState gl:GL_VERTEX_ARRAY)
            (set-polygons-buffer gl)
            (set! *shader-program* (make-shader-program gl (file-as-string-constant "identityshader.vert") (file-as-string-constant "identityshader.frag")))
            (define pos-attrib ::int (gl:glGetAttribLocation *shader-program* "position"))
            (gl:glVertexAttribPointer pos-attrib 3 gl:GL_FLOAT #f 24 0)
            (gl:glEnableVertexAttribArray pos-attrib)
            (define color-attrib ::int (gl:glGetAttribLocation *shader-program* "color"))
            (gl:glVertexAttribPointer color-attrib 3 gl:GL_FLOAT #f 24 12)
            (gl:glEnableVertexAttribArray color-attrib)
            (gl:glUseProgram *shader-program*)
        )
    )
    ((dispose drawable) #!void)
    ((reshape drawable x y w h) #!void)
))
(glcanv:addKeyListener (object (java.awt.event.KeyListener)
    ((keyPressed ev)
        ; split a random asteroid, for testing purposes, when 's' is pressed
        (when (equal? (ev:getKeyCode) KeyEvent:VK_S)
            (define a (*active-asteroids* (random (*active-asteroids*:size))))
            (a:split)
            (*active-asteroids*:remove a)
        )
        (*currently-held-keys*:add (ev:getKeyCode))
    )
    ((keyReleased ev)
        (*currently-held-keys*:remove (ev:getKeyCode))
    )
    ((keyTyped ev) #!void)
))
(glcanv:addMouseListener (object (java.awt.event.MouseListener)
    ((mouseClicked ev)
        (unless (equal? *main-window-matrix* #!null)
            (define output (float[] length: 3))
            (*main-window-matrix*:gluUnProject (ev:getX) (ev:getY) 0 (int[] 0 0 640 480) 0 output 0)
            (printf "mouse clicked at (%s, %s) window coords (%s, %s) object coords\n" (ev:getX) (ev:getY) (output 0) (output 1))
        )
    )
    ; consider making a macro that generates these stubs for all methods of an interface, except for ones written
    ((mouseEntered ev) #!void)
    ((mouseExited ev) #!void)
    ((mousePressed ev) #!void)
    ((mouseReleased ev) #!void)
))
(jf:add glcanv)
(jf:setVisible #t)
(define anim (com.jogamp.opengl.util.FPSAnimator glcanv 30))
(anim:start)
