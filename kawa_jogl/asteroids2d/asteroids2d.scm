(require 'list-lib)
(define GL2 javax.media.opengl.GL2)
(define KeyEvent java.awt.event.KeyEvent)
(define printf java.lang.System:out:printf)
(define-alias ArrayList java.util.ArrayList)

(define-macro (thunk expr) `(lambda () ,expr))
(define-macro (mvbind vars expr . body) `(call-with-values (thunk ,expr) (lambda ,vars ,@body)))
(define-macro (mvlist expr) `(call-with-values (thunk ,expr) list))

; this has multiple-evaluation problems, but works fine for simple cases (does kawa have get-setf-expansion?)
(define-macro (inc! var delta) `(set! ,var (+ ,var ,delta)))
(define-macro (inplace! fn var) `(set! ,var (,fn ,var)))

(define-macro (java-iterate iterable-expr varname . body)
    (define real-varname (if (list? varname) (car varname) varname))
    (define vartype (if (list? varname) (cadr varname) java.lang.Object))
    (define iterator-name (if (and (list? varname) (>= (length varname) 3)) (caddr varname) (gentemp)))
    `(let ((,iterator-name ::java.util.Iterator (invoke ,iterable-expr 'iterator))
           (,real-varname ::,vartype #!null))
        (do ()
            ((not (invoke ,iterator-name 'hasNext)) #!void)
            (set! ,real-varname (invoke ,iterator-name 'next))
            ,@body
        )
    )
)

(define-constant +screen-width+ 640)
(define-constant +screen-height+ 480)

(define (upto x) (do ((i 0 (+ i 1)) (acc '() (cons i acc))) ((= i x) (reverse! acc))))
(define (clamp lo hi) (lambda (val) (max lo (min hi val))))
(define (wrap lo hi) (lambda (val)
    (cond ((< val lo) hi)
          ((> val hi) lo)
          (else val)
    )
))
(define (constantly x) (lambda (. args) x))
(define tau (* 8 (atan 1)))
(define atan2 java.lang.Math:atan2)

(define-simple-class vertex ()
    (x::double 0) (y::double 0)
    ((*init*) #!void)
    ((*init* ix iy)
        (set! x ix)
        (set! y iy)
    )
    ((toString)::String (String:format "c(%f, %f)" x y))
)

(define-simple-class polar-vertex ()
    (m::double 0) (t::double 0)
    ((*init*) #!void)
    ((*init* im it)
        (set! m im)
        (set! t it)
    )
    ((toString)::String (String:format "p(%f, %f)" m t))
)

(define (cart->polar v::vertex) (polar-vertex (sqrt (+ (square v:x) (square v:y))) (atan2 v:y v:x)))
(define (polar->cart p::polar-vertex) (vertex (* p:m (cos p:t)) (* p:m (sin p:t))))
(define (cart+ v1::vertex v2::vertex) (vertex (+ v1:x v2:x) (+ v1:y v2:y)))

; returns a list of vertices of a "regular" polygon, with center at pos, first vertex at rot radians
; the radius parameter is a function to allow non-regular polygons such as isosceles triangles
(define (calc-poly pos rot radiusf sides)
    (map (lambda (i)
        (define rad (radiusf i))
        (define polyvert (polar->cart (polar-vertex rad (+ rot (* tau (/ i sides))))))
        (cart+ pos polyvert)
    ) (upto sides))
)

(define-simple-class drawer () interface: #t
    ((draw gl2::GL2) #!abstract)
)

(define (drawPolygon gl2::GL2 color verts)
    (gl2:glBegin gl2:GL_POLYGON)
    (apply gl2:glColor3d (map (lambda (x) (/ x 255)) color))
    (for-each (lambda (v::vertex)
        (gl2:glVertex2d v:x v:y)
    ) verts)
    (gl2:glEnd)
)

(define-constant +shot-color+ '(255 255 255))
(define-constant +shot-speed+ .1)

(define-simple-class shot (drawer)
    (x 0) (y 0)
    (rot 0)
    (velocity 0)
    ((*init* ix iy irot ivel)
        (set! x ix)
        (set! y iy)
        (set! rot irot)
        (set! velocity (+ ivel +shot-speed+)) ; shots start off with the ship's velocity added to the constant
    )
    ((updatePosition)
        (set! x (+ x (* velocity (cos rot))))
        (set! y (+ y (* velocity (sin rot))))
    )
    ((draw gl2) (drawPolygon gl2 +shot-color+ (calc-poly (vertex x y) rot (constantly .01) 10)))
)

(define-constant +frames-between-shots+ 5)
(define *active-shots*::ArrayList[shot] (ArrayList))

(define-simple-class ship (drawer)
    (x 0) (y 0)
    (rot (/ tau 4))
    (velocity 0)
    (size .1)
    (color '(255 128 0))
    (shooting-cooldown 0) ; in frames for now, probably should make more robust by handling milliseconds
    ((*init*) #!void)
    ((getVerts) (calc-poly (vertex x y) rot (lambda (i) (if (= i 0) (* 2 size) size)) 3)) ; isosceles triangle
    ((updatePosition)
        (if (> shooting-cooldown 0) (inc! shooting-cooldown -1))
        (set! x (+ x (* velocity (cos rot))))
        (set! y (+ y (* velocity (sin rot))))
        (inplace! (wrap -1 1) x)
        (inplace! (wrap -1 1) y)
    )
    ((draw gl2::GL2) (drawPolygon gl2 color (getVerts)))
    ((shoot)
        (*active-shots*:add (shot x y rot velocity))
        (set! shooting-cooldown +frames-between-shots+)
    )
)

(define player-ship (ship))

(define jf (javax.swing.JFrame))
(jf:setSize +screen-width+ +screen-height+)
(jf:setResizable #f)
(jf:setDefaultCloseOperation javax.swing.JFrame:EXIT_ON_CLOSE)
(define glcanv (javax.media.opengl.awt.GLCanvas))

(define *currently-held-keys* (java.util.HashSet))
(define-constant +rotation-delta+ (/ tau 64))
(define-constant +velocity-delta+ .01)
(define (event-loop)
    (if (*currently-held-keys*:contains KeyEvent:VK_LEFT) (inc! player-ship:rot +rotation-delta+))
    (if (*currently-held-keys*:contains KeyEvent:VK_RIGHT) (inc! player-ship:rot (- +rotation-delta+)))
    (if (*currently-held-keys*:contains KeyEvent:VK_UP) (inc! player-ship:velocity +velocity-delta+))
    (if (*currently-held-keys*:contains KeyEvent:VK_DOWN) (inc! player-ship:velocity (- +velocity-delta+)))
    (if (and (*currently-held-keys*:contains KeyEvent:VK_SPACE) (= player-ship:shooting-cooldown 0))
        (player-ship:shoot))
    (player-ship:updatePosition)
    (define wr (wrap -1 1))
    (java-iterate *active-shots* (s shot iter)
        (s:updatePosition)
        (if (not (and (= (wr s:x) s:x) (= (wr s:y) s:y)))
            (iter:remove))
    )
    ;(printf "pos: %s, %s\n" player-ship:x player-ship:y)
)

(define (render gl2::GL2)
    (event-loop) ; might be a good idea to move this out of render later
    (gl2:glClear gl2:GL_COLOR_BUFFER_BIT)
    (player-ship:draw gl2)
    (java-iterate *active-shots* (s shot) (s:draw gl2))
)
(glcanv:addGLEventListener (object (javax.media.opengl.GLEventListener)
    ((*init*) #!void)
    ((display drawable) (render ((drawable:getGL):getGL2)))
    ((init drawable) #!void)
    ((dispose drawable) #!void)
    ((reshape drawable x y w h) #!void)
))
(glcanv:addKeyListener (object (java.awt.event.KeyListener)
    ((keyPressed ev) 
        (*currently-held-keys*:add (ev:getKeyCode))
    )
    ((keyReleased ev)
        (*currently-held-keys*:remove (ev:getKeyCode))
    )
    ((keyTyped ev) #!void)
))
(jf:add glcanv)
(jf:setVisible #t)
(define anim (com.jogamp.opengl.util.FPSAnimator glcanv 30))
(anim:start)
