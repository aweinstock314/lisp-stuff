(require <asteroids_util>)

(define-constant +screen-width+ 640)
(define-constant +screen-height+ 480)

; the real values are double this, since these are used as plus/minus
(define-constant +logical-width+ 4)
(define-constant +logical-height+ 4)
(define +viewport-width+ 3)
(define +viewport-height+ 3)

(define-simple-class drawer () interface: #t
    ((draw gl2::GL2) #!abstract)
)

(define-constant *score-fmtstr* "Score: %s")
(define *score* 0)
(define *scorelabel* (javax.swing.JLabel (String:format *score-fmtstr* *score*)))
(define-constant *lives-fmtstr* "Lives: %s")
(define *lives* 3)
(define *liveslabel* (javax.swing.JLabel (String:format *lives-fmtstr* *lives*)))
(define-constant *level-fmtstr* "Level: %s")
(define *level* 1)
(define *levellabel* (javax.swing.JLabel (String:format *level-fmtstr* *level*)))

(define-constant +label-dimensions+ (java.awt.Dimension 128 32))
(define (initialize-label jframe::javax.swing.JFrame label::javax.swing.JLabel x y)
    (label:setPreferredSize +label-dimensions+)
    (jframe:add label)
    (label:setBounds x y (+label-dimensions+:getWidth) (+label-dimensions+:getHeight))
)
(define (update-label label::javax.swing.JLabel fmt::String val::String)
    (label:setText (String:format fmt val))
    (label:validate)
    (label:repaint)
)

(define-constant +cs-per-frame+ (/ 100 30)) ; centiseconds

(define-constant +shot-color+ '(1 1 1))
(define-constant +shot-speed+ (/ .1 +cs-per-frame+))
(define-constant +shot-size+ .01)
(define-constant +shot-momentum-factor+ 5)
(define-constant +shot-duration+ (* 45 +cs-per-frame+))
(define-constant +shot-vertidx+ (append-polygon-to-global-buffer (calc-poly 0 (constantly +shot-size+) 10 (constantly (apply values +shot-color+)))))

(define-simple-class shot (drawer)
    (x::double 0) (y::double 0)
    (rot::double 0)
    (velocity::double 0)
    (centiseconds-until-decay::int +shot-duration+)
    ((*init* ix iy irot ivel)
        (set! x ix)
        (set! y iy)
        (set! rot irot)
        (set! velocity (+ ivel +shot-speed+)) ; shots start off with the ship's velocity added to the constant
    )
    ((updatePosition!)
        (inc! centiseconds-until-decay -1)
        (set-values! (x y) (apply-polar-movement x y velocity rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((expired?) (< centiseconds-until-decay 0))
    ((draw gl2) (drawPolygon gl2 x y rot +shot-vertidx+))
)

(define-constant +centiseconds-between-shots+ (* 10 +cs-per-frame+))
(define-constant +min-ship-speed+ (/ -0.09 +cs-per-frame+))
(define-constant +max-ship-speed+ (/ 0.10 +cs-per-frame+))
(define *active-shots*::ArrayList[shot] (ArrayList))

(define-simple-class ship (drawer)
    (x::double 0) (y::double 0)
    (rot::double (/ tau 4))
    (velocity::double 0)
    (size .1)
    (color '(1 .5 0))
    (shooting-cooldown::int 0)
    ((*init*) (recalcVerts!) (set! rot (/ tau 4)))
    (vertidx)
    ((recalcVerts!) (set! vertidx (append-polygon-to-global-buffer (calc-poly 0 (lambda (i) (if (= i 0) (* 2 size) size)) 3 (constantly (apply values color)))))) ; isosceles triangle
    ((rotate delta::double) (inc! rot delta))
    ((getVertidx) vertidx)
    ((updatePosition!)
        (if (> shooting-cooldown 0) (inc! shooting-cooldown -1))
        (set-values! (x y) (apply-polar-movement x y velocity rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((draw gl2) (drawPolygon gl2 x y rot vertidx))
    ((shoot)
        (*active-shots*:add (shot x y rot velocity))
        (set! shooting-cooldown +centiseconds-between-shots+)
    )
    ((resetPosition&Momentum!)
        (set!* (x y rot velocity) (0 0 (/ tau 4) 0))
    )
)

(define-constant +min-asteroid-size+ .1)
(define-constant +max-asteroid-size+ .5)
(define-constant +min-asteroid-ivel+ (/ .01 +cs-per-frame+))
(define-constant +max-asteroid-ivel+ (/ .05 +cs-per-frame+))
(define +asteroid-speed-multiplier+ 1)

(define-simple-class asteroid (drawer)
    (x::double (random-range (- +logical-width+) +logical-width+))
    (y::double (random-range (- +logical-height+) +logical-height+))
    (rot::double (random tau))
    (velocity::double (random-range +min-asteroid-ivel+ +max-asteroid-ivel+))
    (size (random-range +min-asteroid-size+ +max-asteroid-size+))
    (color (list (random-range .25 .65) 0 0))
    (vertidx #!null)
    (children::ArrayList[asteroid] #!null)
    (dx::double 0) (dy::double 0) ; deltas from center of generated polygon, for children
    ((constructor-helper poly::polygon) access: 'private
        (set! vertidx (append-polygon-to-global-buffer poly))
        (set! children (ArrayList-map asteroid (divide-poly poly)))
        (receive (xs ys) (ArrayList-foldl
                (lambda (acc v::vertex) (receive (xs ys) acc (values (cons v:x xs) (cons v:y ys))))
                poly:verts
                (values '() '())
            )
            (set!* (dx dy) ((apply average xs) (apply average ys)))
        )
    )
    ((*init*)
        (constructor-helper (calc-poly (random tau) (constantly size) (random-range 3 9) (constantly (apply values color))))
    )
    ((*init* poly::polygon) (constructor-helper poly))

    ((draw gl2) (drawPolygon gl2 x y rot vertidx))
    ((updatePosition!)
        (set-values! (x y) (apply-polar-movement x y (* +asteroid-speed-multiplier+ velocity) rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((split r v) ; takes rotation and velocity of incoming shot, for momentum calculation
        ;(printf "splitting asteroid at (%f, %f), %d children\n" x y (children:size))
        (inc! *score* 1)
        (java-iterate children c
            (set!* (c:x c:y) (x y))
            ; maybe add some factor based on child centers, instead of the random factor?
            (define randfactor (random-range (/ (- tau) 16) (/ tau 16)))
            (define c1 (polar->cart (values (* v +shot-momentum-factor+ +shot-size+) r)))
            (define c2 (polar->cart (values (* velocity size) rot)))
            (receive (m t) (cart->polar (cart+ c1 c2))
                (set!* (c:velocity c:rot) ((/ m size) (ensure-proper-angle (+ randfactor t))))
            )
            (*active-asteroids*:add c)
        )
    )
)

(define *active-asteroids*::ArrayList[asteroid] (ArrayList))
(define (spawn-asteroids! amount::integer)
    (pascal-for (i 0 amount 1) (*active-asteroids*:add (asteroid)))
)
(spawn-asteroids! 5)

(define (closest-asteroid-to-point x y)::asteroid
    (define (sqr-dist a::asteroid)
        (define dx (- (- a:x a:dx) x))
        (define dy (- (- a:y a:dy) y))
        (define sd (+ (* dx dx) (* dy dy))) ; workaround for "java.lang.Double cannot be cast to gnu.math.Quantity"
        ;(printf "squaredist between (%s, %s) and (%s, %s) is %s\n" x y a:x a:y sd)
        (cons a sd)
    )
    ; this type of transform is probably rather inefficient without deforestation and inlining, revise later
    (car (ArrayList-foldl (lambda (acc elem) (if (< (cdr acc) (cdr elem)) acc elem))
            (ArrayList-map sqr-dist *active-asteroids*)
            (cons #!null Integer:MAX_VALUE)
        )
    )
)

(define (asteroids-near-point x y thresh)
    (define (sqr-dist a::asteroid)
        (define dx (- a:x x))
        (define dy (- a:y y))
        (define sd (+ (* dx dx) (* dy dy))) ; workaround for "java.lang.Double cannot be cast to gnu.math.Quantity"
        ;(printf "squaredist between (%s, %s) and (%s, %s) is %s\n" x y a:x a:y sd)
        (cons a sd)
    )
    (define sqrthresh (* thresh thresh))
    ; this type of transform is probably rather inefficient without deforestation and inlining, revise later
    (ArrayList-foldl (lambda (acc elem) (if (< (cdr elem) sqrthresh) (cons (car elem) acc) acc))
        (ArrayList-map sqr-dist *active-asteroids*)
        '()
    )
)

(define (split-if-closest-asteroid-overlaps-point! x y rot vel)
    (define a (closest-asteroid-to-point x y))
    (if (equal? a #!null) #f
        (if (inside-poly? *polygons-buffer* a:vertidx a:x a:y a:rot x y)
            (begin
                (a:split rot vel)
                (*active-asteroids*:remove a)
                #t
            )
            #f
        )
    )
)

(define (split-if-nearby-asteroid-overlaps-point! x y rot vel)
    (call-with-current-continuation (lambda (break)
        (for-each (lambda (a::asteroid)
            (when (inside-poly? *polygons-buffer* a:vertidx a:x a:y a:rot x y)
                (a:split rot vel)
                (*active-asteroids*:remove a)
                (break #t)
            )
        ) (asteroids-near-point x y .5))
        (break #f)
    ))
)

(define player-ship (ship))

(define (player-death!)
    (player-ship:resetPosition&Momentum!)
    (set! *use-respawn-safety-box* #t)
    (inc! *lives* -1)
    (if (< *lives* 0)
        (begin (printf "Game over, no lives left.\n") (java.lang.System:exit 0))
        (printf "Lives-remaining: %s\n" *lives*)
    )
)

(define *buffer-needs-reset* #f)

(define (level-cleared!)
    (printf "Level %s cleared! Making %s new asteroids!\n" *level* (* *level* 5))
    (inc! *level* 1)
    (player-ship:resetPosition&Momentum!)
    (set! *use-respawn-safety-box* #t)
    (spawn-asteroids! (* *level* 5))
    (set! *buffer-needs-reset* #t)
)

(define jf (javax.swing.JFrame))
(define *show-extra-debugging-views* #f)
(define +window-width+ +screen-width+)
(define +window-height+ (if *show-extra-debugging-views* (* 1.5 +screen-height+) +screen-height+))
(jf:setSize +window-width+ +window-height+)
(jf:setResizable #f)
(jf:setDefaultCloseOperation javax.swing.JFrame:EXIT_ON_CLOSE)
(define glcanv (javax.media.opengl.awt.GLCanvas))

(define *use-respawn-safety-box* #t)
(define-constant +respawn-box-vertidx+ (append-polygon-to-global-buffer (calc-poly (/ tau 8) (constantly (sqrt 2)) 4 (constantly (values 0 .25 .25)))))
(define push-outside-respawn-safety-box (push-outside -1 -1 2 2))

(define *currently-held-keys* (java.util.HashSet))
(define displayed-victory-message #f)
(define-constant +rotation-delta+ (/ (/ tau 64) +cs-per-frame+))
(define-constant +velocity-delta+ (/ .01 (* 2 +cs-per-frame+)))
(define (event-loop)
    (define-macro (key-held? key) `(*currently-held-keys*:contains (static-field KeyEvent ,key)))
    (if (key-held? 'VK_LEFT) (player-ship:rotate +rotation-delta+))
    (if (key-held? 'VK_RIGHT) (player-ship:rotate (- +rotation-delta+)))
    (if (key-held? 'VK_UP) (inc! player-ship:velocity +velocity-delta+))
    (if (key-held? 'VK_DOWN) (inc! player-ship:velocity (- +velocity-delta+)))
    (inplace! (clamp +min-ship-speed+ +max-ship-speed+) player-ship:velocity)
    (if (and (key-held? 'VK_SPACE) (= player-ship:shooting-cooldown 0)) (player-ship:shoot))
    (player-ship:updatePosition!)
    (java-iterate *active-shots* (s shot iter)
        (s:updatePosition!)
        (if (or (split-if-nearby-asteroid-overlaps-point! s:x s:y s:rot s:velocity) (s:expired?))
            (iter:remove)
        )
    )
    (java-iterate *active-asteroids* (a asteroid)
        (a:updatePosition!)
        (if *use-respawn-safety-box* (set-values! (a:x a:y) (push-outside-respawn-safety-box a:x a:y)))
        (if (inside-poly? *polygons-buffer* a:vertidx a:x a:y a:rot player-ship:x player-ship:y)
            (player-death!)
        )
    )
    (when (and (*active-asteroids*:isEmpty) (not displayed-victory-message))
        (printf "All asteroids have been cleared!\n")
        (level-cleared!)
        ;(set! displayed-victory-message #t)
        ;(javax.swing.JOptionPane:showMessageDialog #!null "All asteroids have been cleared!")
        ;(exit 0)
    )
    ;(printf "pos: %s, %s\n" player-ship:x player-ship:y)
    (update-label *scorelabel* *score-fmtstr* *score*)
    (update-label *liveslabel* *lives-fmtstr* *lives*)
    (update-label *levellabel* *level-fmtstr* *level*)
)

(define-constant +background-intensity+ .5)


(define-constant background (append-polygon-to-global-buffer (calc-poly
    (/ tau 8) (constantly (sqrt (* 2 (square +logical-width+)))) 4
    (lambda (i) (case i
        ((0) (values +background-intensity+ +background-intensity+ 0))
        ((1) (values 0 +background-intensity+ +background-intensity+))
        ((2) (values 0 0 +background-intensity+))
        ((3) (values 0 +background-intensity+ 0))
    ))
)))

(define-constant white-bg (append-polygon-to-global-buffer (calc-poly 0 (constantly 20) 4 (constantly (values 1 1 1)))))
(define-constant black-dot (append-polygon-to-global-buffer (calc-poly 0 (constantly .01) 10 (constantly (values 0 0 0)))))
(define-constant blue-dot (append-polygon-to-global-buffer (calc-poly 0 (constantly .01) 10 (constantly (values 0 0 1)))))
(define (draw-dotted-line gl2 dot x1 y1 x2 y2)
    (let* ( (density 20)
            (dx (- x2 x1))
            (dy (- y2 y1))
            (dist (java.lang.Math:sqrt (+ (* dx dx) (* dy dy))))
            (slope (atan2 dy dx))
          )
        (pascal-for (i 0 density 1)
            (define j (/ i density))
            (drawPolygon gl2 (+ x1 (* j dist (cos slope))) (+ y1 (* j dist (sin slope))) 0 blue-dot)
        )
    )
)

(define (draw-background gl2::GL2)
    (drawPolygon gl2 0 0 0 background)
)

(define *whole-area-matrix*::PMVMatrix #!null)
(define *whole-area-dims*::int[] #!null)
(define *recent-mouse-obj-coords* (values 0 0))

(define (render gl2::GL2)
    (when *buffer-needs-reset*
        (reset-polygons-buffer! gl2)
        (set! *buffer-needs-reset* #f)
    )
    (gl2:glClear gl2:GL_COLOR_BUFFER_BIT)
    (define-constant (set-projection gl2::GL2 width::double height::double)
        (gl2:glMatrixMode gl2:GL_PROJECTION)
        (gl2:glLoadIdentity)
        (gl2:glOrtho (- width) width 
                     (- height) height
                     1 -1)
;        (define proj-matrix (int[] length: 16))
;        (gl2:glGetIntegerv gl2:GL_PROJECTION_MATRIX proj-matrix 0)
;        (display proj-matrix) (newline)
    )
    (define-constant (prepare-frame gl2::GL2 cx cy ox oy) ; center and offset
        (gl2:glMatrixMode gl2:GL_MODELVIEW)
        (gl2:glLoadIdentity)
        (gl2:glTranslated (- cx) (- cy) 0)
        (gl2:glTranslated (- ox) (- oy) 0)
    )
    (define-constant (draw-foreground gl2 cx cy)
        (if *use-respawn-safety-box* (drawPolygon gl2 0 0 0 +respawn-box-vertidx+))
        (player-ship:draw gl2)
        (define-macro (draw-if-within-bounds x)
            `(when (and (< (abs (- (field ,x 'x) cx)) +viewport-width+)
                        (< (abs (- (field ,x 'y) cy)) +viewport-height+))
                ;(printf "drawing something at (%s, %s)\n" (field ,x 'x) (field ,x 'y))
                (invoke ,x 'draw gl2)
            )
        )
        ;(printf "\n-----\n")
        (java-iterate *active-shots* (s shot) (draw-if-within-bounds s))
        (java-iterate *active-asteroids* (a asteroid) (draw-if-within-bounds a))
    )
    (define-constant (draw-whole-area gl2 x y w h)
        (gl2:glViewport x y w h)
        (set-projection gl2 +logical-width+ +logical-height+)
        (prepare-frame gl2 0 0 0 0)
        (draw-background gl2)
        (draw-foreground gl2 0 0)
        (if (equal? *whole-area-dims* #!null) (set! *whole-area-dims* (int[] x y w h)))
        (if (equal? *whole-area-matrix* #!null) (set! *whole-area-matrix* (getPMVMatrix gl2)))
    )
    (define-constant (draw-shipview gl2 x y w h)
        (gl2:glViewport x y w h)
        (set-projection gl2 +viewport-width+ +viewport-height+)
        ; display 4 copies (in positions based on the quadrant of the ship) to ensure that objects on the wrapped sides appear properly
        (define min-x (if (> player-ship:x 0) -1 0))
        (define max-x (+ (if (> player-ship:x 0) 0 1) 1))
        (define min-y (if (> player-ship:y 0) -1 0))
        (define max-y (+ (if (> player-ship:y 0) 0 1) 1))
        ;(printf "(%s, %s) -> (%s, %s), (%s, %s)\n" player-ship:x player-ship:y min-x min-y max-x max-y)
        (pascal-for (i min-x max-x 1) (pascal-for (j min-y max-y 1)
            (let ((ox (* 2 i +logical-width+)) (oy (* 2 j +logical-height+)))
                (prepare-frame gl2 player-ship:x player-ship:y ox oy)
                (draw-background gl2)
            )
        ))
        (pascal-for (i min-x max-x 1) (pascal-for (j min-y max-y 1)
            (let ((ox (* 2 i +logical-width+)) (oy (* 2 j +logical-height+)))
                (prepare-frame gl2 player-ship:x player-ship:y ox oy)
                (draw-foreground gl2 (+ player-ship:x ox) (+ player-ship:y oy))
            )
        ))
    )
    (define-constant (draw-debugging-poly gl2 x y w h)
        (gl2:glViewport x y w h)
        (set-projection gl2 1 1)
        (drawPolygon gl2 0 0 0 white-bg)
        (receive (px py) *recent-mouse-obj-coords*
            ;(printf "recent mouse coords (%s, %s)\n" px py)
            (define a (closest-asteroid-to-point px py))
            (unless (equal? a #!null)
                ;(printf "asteroid loc (%s, %s)\n" a:x a:y)
                (drawPolygon gl2 0 0 0 a:vertidx)
                (define xy (untranslate/rotate a:x a:y a:rot px py))
                ;(printf "translated pt (%s, %s)\n" (xy 0) (xy 1))
                (drawPolygon gl2 (xy 0) (xy 1) 0 black-dot)
                (define (getter vertidx offset)
                    (*polygons-buffer*:position (* (car vertidx) 6))
                    (*polygons-buffer*:position (+ (*polygons-buffer*:position) offset))
                    (*polygons-buffer*:get)
                )
                (draw-dotted-line gl2 blue-dot 0 0 (getter a:vertidx 0) (getter a:vertidx 1))
            )
        )
    )
    (if *show-extra-debugging-views*
        (begin
            (draw-whole-area gl2 0 (- +window-height+ +screen-height+) +screen-width+ +screen-height+)
            (draw-debugging-poly gl2 (/ +screen-width+ 2) 0 (/ +screen-width+ 2) (/ +screen-height+ 2))
            (draw-shipview gl2 0 0 (/ +screen-width+ 2) (/ +screen-height+ 2))
        )
        (draw-shipview gl2 0 (- +window-height+ +screen-height+) +screen-width+ +screen-height+)
    )
)

(define *shader-program* ::int 0)

(define (reset-polygons-buffer! gl2::GL2)
        (set-polygons-buffer gl2)
        (set! *shader-program* (make-shader-program gl2 (file-as-string-constant "identityshader.vert") (file-as-string-constant "identityshader.frag")))
        (define pos-attrib ::int (gl2:glGetAttribLocation *shader-program* "position"))
        (gl2:glVertexAttribPointer pos-attrib 3 gl2:GL_FLOAT #f 24 0)
        (gl2:glEnableVertexAttribArray pos-attrib)
        (define color-attrib ::int (gl2:glGetAttribLocation *shader-program* "color"))
        (gl2:glVertexAttribPointer color-attrib 3 gl2:GL_FLOAT #f 24 12)
        (gl2:glEnableVertexAttribArray color-attrib)
        (gl2:glUseProgram *shader-program*)
)
(define *eventloop-render-mutex* (java.lang.Object))
(glcanv:addGLEventListener (object (javax.media.opengl.GLEventListener)
    ((*init*) #!void)
    ((display drawable) (synchronized *eventloop-render-mutex* (render ((drawable:getGL):getGL2))))
    ((init drawable)
        (let ((gl (javax.media.opengl.DebugGL2 ((drawable:getGL):getGL2))))
            ;(gl:glEnableClientState gl:GL_VERTEX_ARRAY)
            (reset-polygons-buffer! gl)
        )
    )
    ((dispose drawable) #!void)
    ((reshape drawable x y w h) #!void)
))

(glcanv:addKeyListener (object (java.awt.event.KeyListener)
    ((keyPressed ev)
        (set! *use-respawn-safety-box* #f) ; only provide until a key is pressed
;;        ; split a random asteroid, for testing purposes, when 's' is pressed
;;        (when (equal? (ev:getKeyCode) KeyEvent:VK_S)
;;            (define a (*active-asteroids* (random (*active-asteroids*:size))))
;;            (a:split 0 0)
;;            (*active-asteroids*:remove a)
;;        )
;;        (when (equal? (ev:getKeyCode) KeyEvent:VK_Q) (inc! +asteroid-speed-multiplier+ -0.1))
;;        (when (equal? (ev:getKeyCode) KeyEvent:VK_W) (inc! +asteroid-speed-multiplier+  0.1))
;;        (inplace! (clamp 0 1) +asteroid-speed-multiplier+)
        (*currently-held-keys*:add (ev:getKeyCode))
    )
    ((keyReleased ev)
        (*currently-held-keys*:remove (ev:getKeyCode))
    )
    ((keyTyped ev) #!void)
))

(define (mousecoords->objcoords x y)
    (if (or (equal? #!null *whole-area-matrix*) (equal? #!null *whole-area-dims*))
        (values 0 0)
        (begin
            (define output (float[] length: 3))
            ; the subtraction is because AWT has the origin at the upper-left, OpenGL has it at bottom-left
            (*whole-area-matrix*:gluUnProject x (- +window-height+ y) 0 *whole-area-dims* 0 output 0)
            (values (output 0) (output 1))
        )
    )
)
(glcanv:addMouseListener (object (java.awt.event.MouseListener)
    ((mouseClicked ev)
        (unless (equal? *whole-area-matrix* #!null)
            (receive (x y) (mousecoords->objcoords (ev:getX) (ev:getY))
                (printf "mouse clicked at (%s, %s) window coords (%s, %s) object coords\n" (ev:getX) (ev:getY) x y)
                (split-if-closest-asteroid-overlaps-point! x y 0 0)
            )
        )
    )
    ; consider making a macro that generates these stubs for all methods of an interface, except for ones written
    ((mouseEntered ev) #!void)
    ((mouseExited ev) #!void)
    ((mousePressed ev) #!void)
    ((mouseReleased ev) #!void)
))
(glcanv:addMouseMotionListener (object (java.awt.event.MouseMotionListener)
    ((mouseMoved ev)
        (set! *recent-mouse-obj-coords* (mousecoords->objcoords (ev:getX) (ev:getY)))
        ;(display *recent-mouse-obj-coords*) (newline)
    )
    ((mouseDragged ev) #!void)
))
(glcanv:addMouseWheelListener (object (java.awt.event.MouseWheelListener)
    ((mouseWheelMoved ev)
        (define delta (* .5 (ev:getWheelRotation)))
        (inc! +viewport-width+ delta)
        (inc! +viewport-height+ delta)
        (inplace! (cut max .5 <>) +viewport-width+)
        (inplace! (cut max .5 <>) +viewport-height+)
        ;(printf "(%s, %s)\n" +viewport-width+ +viewport-height+)
    )
))
(jf:setLayout #!null)
(initialize-label jf *scorelabel* 0 0)
(initialize-label jf *liveslabel* (- +window-width+ (+label-dimensions+:getWidth)) 0)
(initialize-label jf *levellabel* (- +window-width+ (+label-dimensions+:getWidth)) (+label-dimensions+:getHeight))
(jf:add glcanv)
(glcanv:setBounds 0 0 640 480)
(jf:setVisible #t)
(define anim (com.jogamp.opengl.util.FPSAnimator glcanv 30))
(anim:start)
(glcanv:requestFocus)
(with-min-ms-per-iteration 10 (synchronized *eventloop-render-mutex* (event-loop)))
