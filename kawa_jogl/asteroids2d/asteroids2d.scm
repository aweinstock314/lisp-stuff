(require <scheme_util_general>)
(require <scheme_util_math>)
(require <asteroids_util_opengl>)

(define +multiplayer-mode+ #f)

(define *constant-buffer* '())
(define (make-constant-polygon poly::polygon) (inplace-polybuffer-append! *constant-buffer* poly))

(define *show-extra-debugging-views* #f)
(define-constant +cs-per-frame+ (/ 100 30)) ; centiseconds
(define-constant +score-fmtstr+ "Score: %s")
(define-constant +lives-fmtstr+ "Lives: %s")
(define-constant +level-fmtstr+ "Level: %s")

(set-variables-from-cmdline 
(
    ((#\h #\? "help") (svfc-display-all-options) (java.lang.System:exit 0))
    (("multiplayer") (set! +multiplayer-mode+ #t))
)
;; GUI settings
(+screen-width+ 640 ("screen-width") Integer:parseInt)
(+screen-height+ 480 ("screen-height") Integer:parseInt)

; the real values are double this, since these are used as plus/minus
(+logical-width+ 4 ("arena-width") parse-double)
(+logical-height+ 4 ("arena-height") parse-double)
(+viewport-width+ 3 ())
(+viewport-height+ 3 ())

(+background-intensity+ .5 ("background-intensity") () parse-double)
(+initial-score+ 0 ("initial-score") () Integer:parseInt)
(+initial-lives+ 3 ("initial-lives") () Integer:parseInt)
(+initial-level+ 1 ("initial-level") () Integer:parseInt)

;; Gameplay settings

(+shot-color+ '(1 1 1) ())
(+shot-speed+ (/ .2 +cs-per-frame+) ("shot-speed") parse-double)
(+shot-size+ .01 ("shot-size") parse-double)
(+shot-momentum-factor+ 2.5 ("shot-momentum") parse-double)
(+shot-duration+ (* (/ 45 2) +cs-per-frame+) ("shot-duration") parse-double)
(+shot-collision-granularity+ 10 () Integer:parseInt)

(+centiseconds-between-shots+ (* 10 +cs-per-frame+) ("shot-delay") parse-double)
(+min-ship-speed+ (/ -0.09 +cs-per-frame+) ("min-ship-speed") parse-double)
(+max-ship-speed+ (/ 0.10 +cs-per-frame+) ("max-ship-speed") parse-double)

(+min-asteroid-size+ .1 ("min-asteroid-size") parse-double)
(+max-asteroid-size+ .5 ("max-asteroid-size") parse-double)
(+min-asteroid-ivel+ (/ .01 +cs-per-frame+) ("min-initial-asteroid-speed") parse-double)
(+max-asteroid-ivel+ (/ .05 +cs-per-frame+) ("max-initial-asteroid-speed") parse-double)
(+asteroid-speed-multiplier+ 1 ("asteroid-speed-multiplier") parse-double)
(+asteroids-per-level+ 5 ("asteroids-per-level") Integer:parseInt)

; these have to do with input sensitivity, not sure if they belong here or in GUI constants section
(+rotation-delta+ (/ (/ tau 64) +cs-per-frame+) ("rotation-sensitivity") parse-double)
(+velocity-delta+ (/ .01 (* 2 +cs-per-frame+)) ("acceleration-sensitivity") parse-double)

) ; end of set-variables-from-cmdline

(define-constant background (make-constant-polygon
;(calc-poly
;    (/ tau 8) (constantly (sqrt (* 2 (square +logical-width+)))) 4
(make-rectangle +logical-width+ +logical-height+
    (lambda (i) (case i
        ((0) (values +background-intensity+ +background-intensity+ 0))
        ((1) (values 0 +background-intensity+ +background-intensity+))
        ((2) (values 0 0 +background-intensity+))
        ((3) (values 0 +background-intensity+ 0))
    ))
)))
(define-constant +respawn-box-vertidx+ (make-constant-polygon (calc-poly (/ tau 8) (constantly (sqrt 2)) 4 (constantly (values 0 .25 .25)))))
(define-constant white-bg (make-constant-polygon (calc-poly 0 (constantly 20) 4 (constantly (values 1 1 1)))))
(define-constant black-dot (make-constant-polygon (calc-poly 0 (constantly .01) 10 (constantly (values 0 0 0)))))
(define-constant blue-dot (make-constant-polygon (calc-poly 0 (constantly .01) 10 (constantly (values 0 0 1)))))
(define-constant +shot-vertidx+ (make-constant-polygon (calc-poly 0 (constantly +shot-size+) 10 (constantly (apply values +shot-color+)))))

(define +window-width+ (if +multiplayer-mode+ (* 2 +screen-width+) +screen-width+))
(define +window-height+ (if *show-extra-debugging-views* (* 1.5 +screen-height+) +screen-height+))

(define-constant +label-dimensions+ (java.awt.Dimension 128 32))
(define-simple-class UnselectableTextField (javax.swing.JFormattedTextField)
    ((processMouseEvent ev::java.awt.event.MouseEvent)::void access: 'protected
        #!void
    )
)
(define (initialize-label c::java.awt.Container label::UnselectableTextField x y)
    (label:setPreferredSize +label-dimensions+)
    (c:add label)
    (label:setBounds x y (+label-dimensions+:getWidth) (+label-dimensions+:getHeight))
)
(define (update-label label::UnselectableTextField fmt::String val::String)
    (label:setValue (String:format fmt val))
)



;; Game objects
(define-simple-class drawer () interface: #t
    ((draw gl2::GL2 is::interface-state) #!abstract)
)

(define-simple-class shot (drawer)
    (x::double 0) (y::double 0)
    (rot::double 0)
    (velocity::double 0)
    (centiseconds-until-decay::int +shot-duration+)
    (play::player) ; originating player, used for scoring
    ((*init* p::player ix iy irot ivel)
        (set! play p)
        (set! x ix)
        (set! y iy)
        (set! rot irot)
        (set! velocity (+ ivel +shot-speed+)) ; shots start off with the ship's velocity added to the constant
    )
    ((updatePosition!)
        (inc! centiseconds-until-decay -1)
        (set-values! (x y) (apply-polar-movement x y velocity rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((expired?) (< centiseconds-until-decay 0))
    ((draw gl2 is) (drawPolygon gl2 is:cbuf x y rot +shot-vertidx+))
)

(define-simple-class ship (drawer)
    (x::double 0) (y::double 0)
    (rot::double (/ tau 4))
    (velocity::double 0)
    (size .1)
    (color '(1 .5 0))
    (shooting-cooldown::int 0)
    (spawnx::double) (spawny::double)
    (shield-active::boolean #t)
    (playernumber::integer 1)
    ((constructor-helper is::interface-state) access: 'private
        (recalcVerts! is)
        (set! rot (/ tau 4))
    )
    ((*init* is::interface-state) (constructor-helper is))
    ((*init* is::interface-state num r g b) (set!* (playernumber color) (num (list r g b))) (constructor-helper is))
    (vertidx)
    ((recalcVerts! is::interface-state) (set! vertidx (is:add-ship-poly (calc-poly 0 (lambda (i) (if (= i 0) (* 2 size) size)) 3 (constantly (apply values color)))))) ; isosceles triangle
    ((rotate delta::double) (inc! rot delta))
    ((getVertidx) vertidx)
    ((updatePosition!)
        (if (> shooting-cooldown 0) (inc! shooting-cooldown -1))
        (set-values! (x y) (apply-polar-movement x y velocity rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((draw gl2 is) (drawPolygon gl2 is:cbuf x y rot vertidx))
    ((shoot! gs::game-state)
        (gs:active-shots:add (shot (invoke gs:players 'get playernumber) x y rot velocity))
        (set! shooting-cooldown +centiseconds-between-shots+)
    )
    ((resetPosition&Momentum!)
        (set!* (x y rot velocity) (spawnx spawny (/ tau 4) 0))
    )
)

(define-alias HashSet java.util.HashSet)
(define-simple-class input-controls ()
    (rotate-left::symbol) (rotate-right::symbol)
    (accelerate::symbol) (decelerate::symbol)
    (shoot::symbol)
    ((*init* rl rr a d s) (set!* (rotate-left rotate-right accelerate decelerate shoot) (rl rr a d s)))
    ((process currently-held-keys::HashSet shp::ship gs::game-state)
        (define-macro (key-held? key) `(invoke currently-held-keys 'contains (static-field KeyEvent ,key)))
        (if (key-held? rotate-left) (shp:rotate +rotation-delta+))
        (if (key-held? rotate-right) (shp:rotate (- +rotation-delta+)))
        (if (key-held? accelerate) (inc! shp:velocity +velocity-delta+))
        (if (key-held? decelerate) (inc! shp:velocity (- +velocity-delta+)))
        (if (and (key-held? shoot) (= shp:shooting-cooldown 0)) (shp:shoot! gs))
        (if (or (key-held? rotate-left) (key-held? rotate-right) (key-held? accelerate) (key-held? decelerate) (key-held? shoot))
            (set! shp:shield-active #f)
        )
    )
)

(define-simple-class asteroid (drawer)
    (x::double (random-range (- +logical-width+) +logical-width+))
    (y::double (random-range (- +logical-height+) +logical-height+))
    (rot::double (random tau))
    (velocity::double (random-range +min-asteroid-ivel+ +max-asteroid-ivel+))
    (size (random-range +min-asteroid-size+ +max-asteroid-size+))
    (color (list (random-range .25 .65) 0 0))
    (vertidx #!null)
    (children::ArrayList[asteroid] #!null)
    (dx::double 0) (dy::double 0) ; deltas from center of generated polygon, for children
    ((constructor-helper is::interface-state poly::polygon) access: 'private
        (set! vertidx (is:add-asteroid-poly poly))
        (set! children (ArrayList-map (cut asteroid is <>) (divide-poly poly)))
        (receive (xs ys) (ArrayList-foldl
                (lambda (acc v::vertex) (receive (xs ys) acc (values (cons v:x xs) (cons v:y ys))))
                poly:verts
                (values '() '())
            )
            (set!* (dx dy) ((apply average xs) (apply average ys)))
        )
    )
    ((*init* is::interface-state)
        (constructor-helper is (calc-poly (random tau) (constantly size) (random-range 3 9) (constantly (apply values color))))
    )
    ((*init* is::interface-state poly::polygon) (constructor-helper is poly))

    ((draw gl2 is) (drawPolygon gl2 is:cbuf x y rot vertidx))
    ((updatePosition!)
        (set-values! (x y) (apply-polar-movement x y (* +asteroid-speed-multiplier+ velocity) rot))
        (inplace! (wrap (- +logical-width+) +logical-width+) x)
        (inplace! (wrap (- +logical-height+) +logical-height+) y)
    )
    ((split gs::game-state s::shot r v) ; takes rotation and velocity of incoming shot, for momentum calculation
        ;(printf "splitting asteroid at (%f, %f), %d children\n" x y (children:size))
        (inc! (field s:play 'score) 1)
        (java-iterate children c
            (set!* (c:x c:y) (x y))
            ; maybe add some factor based on child centers, instead of the random factor?
            (define randfactor (random-range (/ (- tau) 16) (/ tau 16)))
            (define c1 (polar->cart (values (* v +shot-momentum-factor+ +shot-size+) r)))
            (define c2 (polar->cart (values (* velocity size) rot)))
            (receive (m t) (cart->polar (cart+ c1 c2))
                (set!* (c:velocity c:rot) ((/ m size) (ensure-proper-angle (+ randfactor t))))
            )
            ((field gs 'active-asteroids):add c)
        )
    )
)

(define-simple-class player ()
    (shp::ship)
    (score +initial-score+)
    (lives +initial-lives+)
    (scorelabel (UnselectableTextField))
    (liveslabel (UnselectableTextField))
    ((*init* s::ship) (set! shp s))
)

(define-simple-class game-state ()
    ((*init* is::interface-state)
        (set! interface is)
        (let ((ship1 (ship interface)))
            (active-ships:add ship1)
            (players:put ship1:playernumber (player ship1))
            (if +multiplayer-mode+
                (player-controls:put ship1 (input-controls 'VK_A 'VK_D 'VK_W 'VK_S 'VK_1))
                (player-controls:put ship1 (input-controls 'VK_LEFT 'VK_RIGHT 'VK_UP 'VK_DOWN 'VK_SPACE))
            )
        )
        (if +multiplayer-mode+ (let ((ship2 (ship interface 2 0 0 1)))
            (active-ships:add ship2)
            (set!* (ship2:spawnx ship2:spawny) (2 0))
            (ship2:resetPosition&Momentum!)
            (players:put ship2:playernumber (player ship2))
            (player-controls:put ship2 (input-controls 'VK_LEFT 'VK_RIGHT 'VK_UP 'VK_DOWN 'VK_SPACE))
        ))
    )
    (interface::interface-state #!null)
    (player-controls::HashMap[ship input-controls] (HashMap))
    (players::HashMap[integer player] (HashMap))
    (active-ships::ArrayList[ship] (ArrayList))
    (active-shots::ArrayList[shot] (ArrayList))
    (active-asteroids::ArrayList[asteroid] (ArrayList))
    (level +initial-level+)
    (levellabel (UnselectableTextField))

    (buffer-needs-reset #f)
    (eventloop-render-mutex (java.lang.Object))

    ((spawn-asteroids! amount::integer)
        (pascal-for (i 0 amount 1) (active-asteroids:add (asteroid interface)))
    )
    ((player-death! p::player iter::java.util.Iterator[player])
        (define shp p:shp)
        (shp:resetPosition&Momentum!)
        (set! shp:shield-active #t)
        (inc! p:lives -1)
        (if (< p:lives 0)
            (begin
                (printf "Game over for player %s.\nTheir score was %s.\n" shp:playernumber p:score)
                (iter:remove)
                (player-controls:remove shp)
                ;(if (= (active-ships:size) 0) (java.lang.System:exit 0))
            )
            (printf "Lives remaining for player %s: %s\n" shp:playernumber p:lives)
        )
    )
    ((level-cleared!)
        (printf "Level %s cleared! Making %s new asteroids!\n" level (* level +asteroids-per-level+))
        (inc! level 1)
        (active-shots:clear)
        (java-iterate active-ships (shp ship)
            (set! shp:shield-active #t)
            (shp:resetPosition&Momentum!)
        )
        (set! interface:asteroids-polybuf '())
        (spawn-asteroids! (* level +asteroids-per-level+))
        (set! buffer-needs-reset #t)
    )
)

(define-simple-class interface-state ()
    (displayed-victory-message #f)
    (currently-held-keys::HashSet (HashSet))
    (shader-program ::int 0)
    (whole-area-matrix::PMVMatrix #!null)
    (whole-area-dims::int[] #!null)
    (recent-mouse-obj-coords (values 0 0))
    (cbuf::concatenated-buffer)
    (ships-polybuf '())
    (asteroids-polybuf '())

    ((add-ship-poly p::polygon) (inplace-polybuffer-append! ships-polybuf p))
    ((add-asteroid-poly p::polygon) (inplace-polybuffer-append! asteroids-polybuf p))

    ((reset-polygons-buffer! gl2::GL2)
            (set! cbuf (concatenate-buffers (append *constant-buffer* ships-polybuf asteroids-polybuf)))
            (set-polygons-buffer gl2 cbuf)
            (set! shader-program (make-shader-program gl2 (file-as-string-constant "identityshader.vert") (file-as-string-constant "identityshader.frag")))
            (define pos-attrib ::int (gl2:glGetAttribLocation shader-program "position"))
            (gl2:glVertexAttribPointer pos-attrib 3 gl2:GL_FLOAT #f 24 0)
            (gl2:glEnableVertexAttribArray pos-attrib)
            (define color-attrib ::int (gl2:glGetAttribLocation shader-program "color"))
            (gl2:glVertexAttribPointer color-attrib 3 gl2:GL_FLOAT #f 24 12)
            (gl2:glEnableVertexAttribArray color-attrib)
            (gl2:glUseProgram shader-program)
    )
    ((mousecoords->objcoords x y)
        (if (or (equal? #!null whole-area-matrix)
                (equal? #!null whole-area-dims))
            (values 0 0)
            (begin
                (define output (float[] length: 3))
                ; the subtraction is because AWT has the origin at the upper-left, OpenGL has it at bottom-left
                (whole-area-matrix:gluUnProject x (- +window-height+ y) 0 whole-area-dims 0 output 0)
                (values (output 0) (output 1))
            )
        )
    )
)

(define (closest-asteroid-to-point asteroids x y)::asteroid
    (define (sqr-dist a::asteroid)
        (define dx (- (- a:x a:dx) x))
        (define dy (- (- a:y a:dy) y))
        (define sd (+ (* dx dx) (* dy dy))) ; workaround for "java.lang.Double cannot be cast to gnu.math.Quantity"
        ;(printf "squaredist between (%s, %s) and (%s, %s) is %s\n" x y a:x a:y sd)
        (cons a sd)
    )
    ; this type of transform is probably rather inefficient without deforestation and inlining, revise later
    (car (ArrayList-foldl (lambda (acc elem) (if (< (cdr acc) (cdr elem)) acc elem))
            (ArrayList-map sqr-dist asteroids)
            (cons #!null Integer:MAX_VALUE)
        )
    )
)

;(define (asteroids-near-point asteroids::ArrayList[asteroid] x y thresh)
;    (define (sqr-dist a::asteroid)
;        (define dx (- a:x x))
;        (define dy (- a:y y))
;        (+ (* dx dx) (* dy dy))
;    )
;    (define sqrthresh (* thresh thresh))
;    (with-list-collector col
;        (java-iterate asteroids (a asteroid)
;            (if (< (sqr-dist a) sqrthresh) (col a))
;        )
;    )
;)

(define-macro (with-asteroids-near-point asteroids x y thresh . body)
    (define sqrthresh (* thresh thresh))
    (define-gensyms xtmp ytmp)
    `(let* (
            (,xtmp ,x)
            (,ytmp ,y)
            (sqr-dist (lambda (a::asteroid)
                (define dx (- a:x ,xtmp))
                (define dy (- a:y ,ytmp))
                (+ (* dx dx) (* dy dy))
            ))
        )
        (java-iterate ,asteroids (a asteroid)
            (if (< (sqr-dist a) ,sqrthresh) ,@body)
        )
    )
)

(define (split-if-closest-asteroid-overlaps-point! gs::game-state is::interface-state x y rot vel)
    (define a (closest-asteroid-to-point gs:active-asteroids x y))
    (if (equal? a #!null) #f
        (if (inside-poly? is:cbuf a:vertidx a:x a:y a:rot x y)
            (begin
                (a:split gs #!null rot vel)
                (gs:active-asteroids:remove a)
                #t
            )
            #f
        )
    )
)

(define (split-if-nearby-asteroid-overlaps-point! gs::game-state is::interface-state s::shot)
    (call-with-current-continuation (lambda (break)
        (pascal-for (i 0 +shot-collision-granularity+ 1)
            (define step-fraction (/ i +shot-collision-granularity+))
            ;(for-each (lambda (a::asteroid)
            (with-asteroids-near-point gs:active-asteroids s:x s:y .5
                (receive (x y) (apply-polar-movement s:x s:y (* s:velocity step-fraction) s:rot)
                    (when (inside-poly? is:cbuf a:vertidx a:x a:y a:rot x y)
                        (a:split gs s s:rot s:velocity)
                        (invoke gs:active-asteroids 'remove a)
                        (break #t)
                    )
                )
            )
            ;) (asteroids-near-point gs:active-asteroids s:x s:y .5))
        )
        (break #f)
    ))
)

(define (event-loop gs::game-state is::interface-state)
    (unless (equal? is:cbuf #!null)
    (java-iterate gs:active-ships (shp ship)
        (aif/nn (invoke gs:player-controls 'get shp) (begin
            (invoke it 'process is:currently-held-keys shp gs)
            (inplace! (clamp +min-ship-speed+ +max-ship-speed+) shp:velocity)
            (shp:updatePosition!)
        ))
    )
    (java-iterate gs:active-shots (s shot iter)
        (s:updatePosition!)
        (if (or (split-if-nearby-asteroid-overlaps-point! gs is s) (s:expired?))
            (iter:remove)
        )
    )
    (java-iterate gs:active-asteroids (a asteroid)
        (a:updatePosition!)
        (java-iterate gs:active-ships (shp ship)
            (when shp:shield-active
                (define respawn-pusher (push-outside (- shp:spawnx 1) (- shp:spawny 1) 2 2)) ; probably optimize by moving this to a field on ship/player later
                (set-values! (a:x a:y) (respawn-pusher a:x a:y))
            )
        )
        (java-iterate gs:active-ships (shp ship iter)
            (if (inside-poly? is:cbuf a:vertidx a:x a:y a:rot shp:x shp:y)
                (gs:player-death! (invoke gs:players 'get shp:playernumber) iter)
            )
        )
    )
    (when (and (gs:active-asteroids:isEmpty) (not is:displayed-victory-message))
        (printf "All asteroids have been cleared!\n")
        (gs:level-cleared!)
    )
    (java-iterate (invoke gs:players 'values) (p player)
        (update-label p:scorelabel +score-fmtstr+ p:score)
        (if (>= p:lives 0)
            (update-label p:liveslabel +lives-fmtstr+ p:lives)
            (update-label p:liveslabel "%s" "Game over.")
        )
    )
    (update-label gs:levellabel +level-fmtstr+ gs:level)
    )
)

(define (render gl2::GL2 gs::game-state is::interface-state width::integer height::integer)
    (when gs:buffer-needs-reset
        (is:reset-polygons-buffer! gl2)
        (set! gs:buffer-needs-reset #f)
    )
    (gl2:glClear gl2:GL_COLOR_BUFFER_BIT)
    (define-constant (set-projection gl2::GL2 width::double height::double)
        (gl2:glMatrixMode gl2:GL_PROJECTION)
        (gl2:glLoadIdentity)
        (gl2:glOrtho (- width) width 
                     (- height) height
                     1 -1)
;        (define proj-matrix (int[] length: 16))
;        (gl2:glGetIntegerv gl2:GL_PROJECTION_MATRIX proj-matrix 0)
;        (display proj-matrix) (newline)
    )
    (define-constant (prepare-frame gl2::GL2 cx cy ox oy) ; center and offset
        (gl2:glMatrixMode gl2:GL_MODELVIEW)
        (gl2:glLoadIdentity)
        (gl2:glTranslated (- cx) (- cy) 0)
        (gl2:glTranslated (- ox) (- oy) 0)
    )
    (define-constant (draw-background gl2::GL2)
        (drawPolygon gl2 is:cbuf 0 0 0 background)
    )
    (define-constant (draw-foreground gl2 cx cy)
        (java-iterate gs:active-ships (shp ship)
            (if shp:shield-active (drawPolygon gl2 is:cbuf shp:spawnx shp:spawny 0 +respawn-box-vertidx+))
        )
        (java-iterate gs:active-ships (shp ship) (shp:draw gl2 is))
        (define-macro (draw-if-within-bounds x)
            `(when (and (< (abs (- (field ,x 'x) cx)) +viewport-width+)
                        (< (abs (- (field ,x 'y) cy)) +viewport-height+))
                ;(printf "drawing something at (%s, %s)\n" (field ,x 'x) (field ,x 'y))
                (invoke ,x 'draw gl2 is)
            )
        )
        ;(printf "\n-----\n")
        (java-iterate gs:active-shots (s shot) (draw-if-within-bounds s))
        (java-iterate gs:active-asteroids (a asteroid) (draw-if-within-bounds a))
    )
    (define-constant (draw-whole-area gl2 x y w h)
        (gl2:glViewport x y w h)
        (set-projection gl2 +logical-width+ +logical-height+)
        (prepare-frame gl2 0 0 0 0)
        (draw-background gl2)
        (draw-foreground gl2 0 0)
        (if (equal? is:whole-area-dims #!null)
            (set! is:whole-area-dims (int[] x y w h))
        )
        (if (equal? is:whole-area-matrix #!null)
            (set! is:whole-area-matrix (getPMVMatrix gl2))
        )
    )
    (define-constant (draw-shipview gl2 shp::ship x y w h)
        (gl2:glViewport x y w h)
        (set-projection gl2 +viewport-width+ +viewport-height+)
        ; display 4 copies (in positions based on the quadrant of the ship) to ensure that objects on the wrapped sides appear properly
        (define px shp:x)
        (define py shp:y)
        (define min-x (if (> px 0) -1 0))
        (define max-x (+ (if (> px 0) 0 1) 1))
        (define min-y (if (> py 0) -1 0))
        (define max-y (+ (if (> py 0) 0 1) 1))
        ;(printf "(%s, %s) -> (%s, %s), (%s, %s)\n" shp:x shp:y min-x min-y max-x max-y)
        (pascal-for (i min-x max-x 1) (pascal-for (j min-y max-y 1)
            (let ((ox (* 2 i +logical-width+)) (oy (* 2 j +logical-height+)))
                (prepare-frame gl2 px py ox oy)
                (draw-background gl2)
            )
        ))
        (pascal-for (i min-x max-x 1) (pascal-for (j min-y max-y 1)
            (let ((ox (* 2 i +logical-width+)) (oy (* 2 j +logical-height+)))
                (prepare-frame gl2 px py ox oy)
                (draw-foreground gl2 (+ px ox) (+ py oy))
            )
        ))
    )
    (define-constant (draw-debugging-poly gl2 x y w h)
        (gl2:glViewport x y w h)
        (set-projection gl2 1 1)
        (drawPolygon gl2 is:cbuf 0 0 0 white-bg)
        (receive (px py) is:recent-mouse-obj-coords
            ;(printf "recent mouse coords (%s, %s)\n" px py)
            (define a (closest-asteroid-to-point gs:active-asteroids px py))
            (unless (equal? a #!null)
                ;(printf "asteroid loc (%s, %s)\n" a:x a:y)
                (drawPolygon gl2 is:cbuf 0 0 0 a:vertidx)
                (define xy (untranslate/rotate a:x a:y a:rot px py))
                ;(printf "translated pt (%s, %s)\n" (xy 0) (xy 1))
                (drawPolygon gl2 is:cbuf (xy 0) (xy 1) 0 black-dot)
                (define (getter vertidx offset)
                    (is:cbuf:buf:position (* (is:cbuf:offset vertidx) 6))
                    (is:cbuf:buf:position (+ (is:cbuf:buf:position) offset))
                    (is:cbuf:buf:get)
                )
                (draw-dotted-line gl2 is:cbuf blue-dot 0 0 (getter a:vertidx 0) (getter a:vertidx 1))
            )
        )
    )
    (if *show-extra-debugging-views*
        (begin
            (draw-whole-area gl2 0 (- +window-height+ +screen-height+) +screen-width+ +screen-height+)
            (draw-debugging-poly gl2 (/ +screen-width+ 2) 0 (/ +screen-width+ 2) (/ +screen-height+ 2))
            (draw-shipview gl2 (invoke gs:players 'get 1):shp 0 0 (/ +screen-width+ 2) (/ +screen-height+ 2))
        )
        (begin
            (draw-shipview gl2 (invoke gs:players 'get 1):shp 0 (- +window-height+ +screen-height+) +screen-width+ +screen-height+)
            (if +multiplayer-mode+
                (draw-shipview gl2 (invoke gs:players 'get 2):shp +screen-width+ (- +window-height+ +screen-height+) +screen-width+ +screen-height+)
            )
        )
    )
)

(define-simple-class asteroids-panel (javax.swing.JPanel javax.media.opengl.GLEventListener java.awt.event.KeyListener java.awt.event.MouseListener java.awt.event.MouseMotionListener java.awt.event.MouseWheelListener)
    (gamestate::game-state)
    (interfacestate::interface-state)
    ; GLEventListener
    ((display drawable) (synchronized gamestate:eventloop-render-mutex (print-exceptions (render ((drawable:getGL):getGL2) gamestate interfacestate (getWidth) (getHeight)))))
    ((init drawable)
        (let ((gl (javax.media.opengl.DebugGL2 ((drawable:getGL):getGL2))))
            ;(gl:glEnableClientState gl:GL_VERTEX_ARRAY)
            (interfacestate:reset-polygons-buffer! gl)
        )
    )
    ((dispose drawable) #!void)
    ((reshape drawable x y w h) #!void)
    ; KeyListener
    ((keyPressed ev)
;;        ; split a random asteroid, for testing purposes, when 's' is pressed
;;        (when (equal? (ev:getKeyCode) KeyEvent:VK_S)
;;            (define a (*active-asteroids* (random (*active-asteroids*:size))))
;;            (a:split 0 0)
;;            (*active-asteroids*:remove a)
;;        )
;;        (when (equal? (ev:getKeyCode) KeyEvent:VK_Q) (inc! +asteroid-speed-multiplier+ -0.1))
;;        (when (equal? (ev:getKeyCode) KeyEvent:VK_W) (inc! +asteroid-speed-multiplier+  0.1))
;;        (inplace! (clamp 0 1) +asteroid-speed-multiplier+)
        (interfacestate:currently-held-keys:add (ev:getKeyCode))
    )
    ((keyReleased ev)
        (interfacestate:currently-held-keys:remove (ev:getKeyCode))
    )
    ((keyTyped ev) #!void)
    ; MouseListener
    ((mouseClicked ev)
        (unless (equal? interfacestate:whole-area-matrix #!null)
            (receive (x y) (interfacestate:mousecoords->objcoords (ev:getX) (ev:getY))
                (printf "mouse clicked at (%s, %s) window coords (%s, %s) object coords\n" (ev:getX) (ev:getY) x y)
                (split-if-closest-asteroid-overlaps-point! gamestate interfacestate x y 0 0)
            )
        )
    )
    ; consider making a macro that generates these stubs for all methods of an interface, except for ones written
    ((mouseEntered ev) #!void)
    ((mouseExited ev) #!void)
    ((mousePressed ev) #!void)
    ((mouseReleased ev) #!void)
    ; MouseMotionListener
    ((mouseMoved ev)
        (set! interfacestate:recent-mouse-obj-coords (interfacestate:mousecoords->objcoords (ev:getX) (ev:getY)))
        ;(display *recent-mouse-obj-coords*) (newline)
    )
    ((mouseDragged ev) #!void)
    ; MouseWheelListener
    ((mouseWheelMoved ev)
        (define delta (* .5 (ev:getWheelRotation)))
        (inc! +viewport-width+ delta)
        (inc! +viewport-height+ delta)
        (inplace! (cut max .5 <>) +viewport-width+)
        (inplace! (cut max .5 <>) +viewport-height+)
        ;(printf "(%s, %s)\n" +viewport-width+ +viewport-height+)
    )
    (glcanv::GLCanvas #!null)
    (anim::FPSAnimator #!null)
    ((*init* w::integer h::integer) #!void
        (set! interfacestate (interface-state))
        (set! gamestate (game-state interfacestate))
        (gamestate:spawn-asteroids! +asteroids-per-level+)
        (setLayout #!null)
        (initialize-label (this) (invoke gamestate:players 'get 1):scorelabel 0 0) ; the "'get 1" is a hack, fix later
        (initialize-label (this) (invoke gamestate:players 'get 1):liveslabel (- +screen-width+ (+label-dimensions+:getWidth)) 0)
        (when +multiplayer-mode+
            (initialize-label (this) (invoke gamestate:players 'get 2):scorelabel +screen-width+ 0)
            (initialize-label (this) (invoke gamestate:players 'get 2):liveslabel (- w (+label-dimensions+:getWidth)) 0)
        )
        (initialize-label (this) gamestate:levellabel (- w (+label-dimensions+:getWidth)) (+label-dimensions+:getHeight))
        ; according to gnu.bytecode.dump, this doesn't get unrolled (a PairWithPosition literal is consed up at module init, and the code that uses that literal cdrs through it, and uses gnu.kawa.reflect.Invoke to execute the symbols)
        (set! glcanv (GLCanvas))
        (for-each (lambda (method) (invoke glcanv method (this)))
            '(addGLEventListener addKeyListener addMouseListener addMouseMotionListener addMouseWheelListener))
        (add glcanv)
        (glcanv:setBounds 0 0 w h)
        (setBounds 0 0 w h)
    )
    ((post-visible-initialization!)
        (glcanv:requestFocus)
        (set! anim (FPSAnimator glcanv 30))
        (anim:start)
        (future (with-min-ms-per-iteration 10 (synchronized gamestate:eventloop-render-mutex (print-exceptions (event-loop gamestate interfacestate)))))
    )
)
(define jf (javax.swing.JFrame))
(define *asteroids-panel*::asteroids-panel (asteroids-panel +window-width+ +window-height+))
(jf:setSize +window-width+ +window-height+)
(jf:setResizable #f)
(jf:setDefaultCloseOperation javax.swing.JFrame:EXIT_ON_CLOSE)
(jf:setLayout #!null)
(jf:add *asteroids-panel*)
(jf:setVisible #t)
(*asteroids-panel*:post-visible-initialization!)
