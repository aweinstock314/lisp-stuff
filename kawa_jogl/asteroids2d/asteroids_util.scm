(require 'list-lib)

(define-macro (with-all-forms-exported . forms)
    (letrec ((helper (lambda (form acc)
                (if (not (list? form)) acc
                (case (car form)
                    ((define-alias define-simple-class) (cons (cadr form) acc))
                    ((define define-constant define-macro)
                        (cons (cond
                            ((pair? (cadr form)) (caadr form))
                            ((symbol? (cadr form)) (cadr form))
                            (else (error "Unexpected type as the second element of a define form"))
                        ) acc)
                    )
                    (else acc)
                ))
            )))
        (define export-list (fold helper '() forms))
        (display "Automagically exporting the following from with-all-forms-exported: ") (newline)
        (display export-list) (newline)
        `(begin ,@forms ,@(if (not (null? export-list)) `((module-export ,@export-list)) '()))
    )
)
(module-export with-all-forms-exported)

(with-all-forms-exported

(define printf java.lang.System:out:printf)
(define-alias GL2 javax.media.opengl.GL2)
(define-alias KeyEvent java.awt.event.KeyEvent)
(define-alias ArrayList java.util.ArrayList)
(define-alias Number java.lang.Number)
(define-alias Integer java.lang.Integer)
(define-alias FloatBuffer java.nio.FloatBuffer)
(define-constant newDirectFloatBuffer com.jogamp.common.nio.Buffers:newDirectFloatBuffer)

(define-macro (thunk . body) `(lambda (. ,(gentemp)) ,@body))
(define-macro (mvbind vars expr . body) `(call-with-values (thunk ,expr) (lambda ,vars ,@body)))
(define-macro (mvlist expr) `(call-with-values (thunk ,expr) list))
(define-macro (returning let-pair . body) `(let (,let-pair) ,@body ,(car let-pair)))
(define-macro (set!* vals exprs) `(begin ,@(map (lambda (val expr) `(set! ,val ,expr)) vals exprs)))
(define-macro (define-gensyms . names) `(begin ,@(map (lambda (name) `(define ,name (gentemp))) names)))
(define-macro (set-values! vars expr)
    (define tmps (map (thunk (gentemp)) vars))
    `(mvbind ,tmps ,expr ,@(map (lambda (var tmp) `(set! ,var ,tmp)) vars tmps))
)

; the first way has multiple-evaluation problems, but works fine for simple cases
; the second way (commented), should be the right way, but generates bytecode that sometimes gives verify errors (revision 7952 fixed a simplified version of this error, which turned out to have been oversimplified)
(define-macro (inc! var delta)
    `(set! ,var (+ ,var ,delta))
    ;(let ((loc (gentemp))) `(let ((,loc (location ,var))) (set! (,loc) (+ (,loc) ,delta))))
)
(define-macro (inplace! fn var)
    `(set! ,var (,fn ,var))
    ;(let ((loc (gentemp))) `(let ((,loc (location ,var))) (set! (,loc) (,fn (,loc)))))
)

(define-macro (java-iterate iterable-expr varname . body)
    (define real-varname (if (list? varname) (car varname) varname))
    (define vartype (if (list? varname) (cadr varname) java.lang.Object))
    (define iterator-name (if (and (list? varname) (>= (length varname) 3)) (caddr varname) (gentemp)))
    `(let ((,iterator-name ::java.util.Iterator (invoke ,iterable-expr 'iterator))
           (,real-varname ::,vartype #!null))
        (do ()
            ((not (invoke ,iterator-name 'hasNext)) #!void)
            (set! ,real-varname (invoke ,iterator-name 'next))
            ,@body
        )
    )
)

(define-macro (pascal-for rng . body)
    (define var (car rng))
    (define-gensyms lo hi step)
    `(let ((,lo ,(cadr rng)) (,hi ,(caddr rng)) (,step ,(cadddr rng)))
        (do ((,var ,lo (+ ,var ,step)))
            ((= ,var ,hi) #!void)
            ,@body
        )
    )
)

(define-macro (with-list-collector col . body)
    (define-gensyms head tail elem)
    `(let* ((,head (cons '() '())) (,tail ,head)
            (,col (lambda (,elem)
                (set! (cdr ,tail) (cons ,elem (cdr ,tail)))
                (inplace! cdr ,tail)
           )))
        ,@body
        (cdr ,head)
    )
)

(define-macro (accumulate-range rng . body)
    (define-gensyms col)
    `(with-list-collector ,col
        (pascal-for ,rng
            (,col (begin ,@body))
        )
    )
)

(define (slurp-file filename::String)::String
    (define buf (java.lang.StringBuilder))
    (define file (open-input-file filename))
    (do ((line (read-line file 'concat) (read-line file 'concat)))
        ((equal? line '#!eof) (buf:toString))
        (buf:append line)
    )
)

; Would be nice to have CL's sharp-dot read-macro for this (so the callsite is just #.(slurp-file "foo"), and this extra macro is unneccessary)
(define-macro (file-as-string-constant filename) (slurp-file filename))

(define-macro (curry expr)
    (define-gensyms argsname)
    `(lambda (. ,argsname) (apply ,@expr ,argsname))
)
(define (complement pred) (lambda (. args) (not (apply pred args))))
(define (compose f g) (lambda (. args) (f (apply g args))))

(define (upto x) (do ((i 0 (+ i 1)) (acc '() (cons i acc))) ((= i x) (reverse! acc))))
(define (clamp lo hi) (lambda (val) (max lo (min hi val))))
(define (wrap lo hi) (lambda (val)
    (cond ((< val lo) hi)
          ((> val hi) lo)
          (else val)
    )
))
(define (within? lo hi) (lambda (val::Number)::boolean (<= lo val hi)))

(define (constantly x) (lambda (. args) x))
(define tau (* 8 (atan 1)))
(define atan2 java.lang.Math:atan2)
(define (rad->deg r) (/ (* r 360) tau))
(define (random x)::float (* x (java.lang.Math:random)))
(define (random-range lo hi)::float (+ lo (* (- hi lo) (java.lang.Math:random))))

(define-simple-class vertex ()
    (x::double 0) (y::double 0) (z::double 0)
    (r::double 0) (g::double 0) (b::double 0)
    ((*init*) #!void)
    ((*init* ix::double iy::double)
        (set! x ix)
        (set! y iy)
    )
    ((toString)::String (String:format "#<xyz(%f, %f, %f), rgb(%f, %f, %f)>" x y z r g b))
)

(define-simple-class polygon ()
    (verts::ArrayList[vertex] (ArrayList))
    ((*init*) #!void)
    ((*init* vertices::ArrayList[vertex]) (set! verts vertices))
)

(define-simple-class polar-vertex ()
    (m::double 0) (t::double 0)
    ((*init*) #!void)
    ((*init* im::double it::double)
        (set! m im)
        (set! t it)
    )
    ((toString)::String (String:format "p(%f, %f)" m t))
)

(define (apply-polar-movement x y mag rot) (values
    (+ x (* mag (cos rot)))
    (+ y (* mag (sin rot)))
))

(define (cart->polar v::vertex) (polar-vertex (sqrt (+ (square v:x) (square v:y))) (atan2 v:y v:x)))
(define (polar->cart p::polar-vertex) (vertex (* p:m (cos p:t)) (* p:m (sin p:t))))
(define (cart+ v1::vertex v2::vertex) (vertex (+ v1:x v2:x) (+ v1:y v2:y)))

; returns a list of vertices of a "regular" polygon, with the first vertex at rot radians
; the radius parameter is a function to allow non-regular polygons such as isosceles triangles
(define (calc-poly rot::double radiusf::gnu.mapping.Procedure sides::int colorf::gnu.mapping.Procedure)
    (returning (poly (polygon)) (pascal-for (i 0 sides 1)
        (let* ((rad::double (radiusf i))
               (ang::double (+ rot (* tau (/ i sides))))
            )
            (let-values (((r g b) (colorf i)))
                (invoke poly:verts 'add (returning (v (vertex))
                    (set!* (v:x v:y v:z) ((* rad (cos ang)) (* rad (sin ang)) 0))
                    (set!* (v:r v:g v:b) (r g b))
                ))
            )
        )
    ))
)

(define (ensure-proper-angle t)
    (cond ((< t 0) (ensure-proper-angle (+ t tau)))
          ((>= t tau) (ensure-proper-angle (- t tau)))
          (#t t)
    )
)

; check if point (px, py) is on the "inside" of a line (calc-poly draws lines counter-clockwise)
(define (inside-line? px py x1 y1 x2 y2)
    (let* ((theta1 (ensure-proper-angle (atan2 (- y2 y1) (- x2 x1))))
           (theta2 (ensure-proper-angle (atan2 (- py y1) (- px x1))))
           (dtheta (ensure-proper-angle (- theta2 theta1))))
        (or (< 0 dtheta (/ tau 4)) (< (* 3/4 tau) dtheta tau))
;        (printf "(%s, %s)\n(%s, %s)\n(%s, %s)\n" px py x1 y1 x2 y2)
;        (printf "theta1 %s; theta2: %s; dtheta: %s\n" (rad->deg theta1) (rad->deg theta2) (rad->deg dtheta))
;        (returning (val (or (< 0 dtheta (/ tau 4)) (< (* 3/4 tau) dtheta tau)))
;            (printf "returning %s from 'inside-line?\n" val)
;        )
    )
)

(define (inside-poly? buf::FloatBuffer vertidx ox oy rot px py)
    (let* ((offset (car vertidx))
           (numverts (cdr vertidx))
           (matmultres (untranslate/rotate ox oy rot px py))
           (nx (matmultres 0)) (ny (matmultres 1))
          )
        (buf:position (* offset 6))
        ;(printf "checking if (%s, %s) is inside asteroid at (%s, %s)\n" px py ox oy)
        (let loop ((oldx (buf:get)) (oldy (buf:get)) (i 0))
            (buf:position (+ (buf:position) 4)) ;skip z, r, g, b, this may need to be modified to include z during the transition to 3d
            ;(printf "bufpos %s\n" (buf:position))
            (if (< i numverts)
                (begin
                    (define newx (buf:get))
                    (define newy (buf:get))
                    (if (inside-line? nx ny oldx oldy newx newy)
                        (loop newx newy (+ i 1))
                        #f
                    )
                )
                #t
            )
        )
    )
)

(define (ArrayList-map fn . arraylists)
    (returning (rv ::ArrayList (ArrayList))
        (define endidx (fold min Integer:MAX_VALUE (map (lambda (x::ArrayList) (x:size)) arraylists)))
        (pascal-for (idx 0 endidx 1)
            (rv:add (apply fn (map (lambda (x::ArrayList) (x:get idx)) arraylists)))
        )
    )
)

(define (ArrayList-foldl fn al::ArrayList initial)
    (returning (acc initial) (pascal-for (i 0 (al:size) 1)
        (set! acc (fn acc (al:get i)))
    ))
)

(define-macro (with-overlapping-slices slicename source groupsize overlap . body)
    (define-gensyms loop idx backamt)
    `(let ((,backamt (if (>= ,overlap ,groupsize) (- ,groupsize 1) ,overlap)))
        (let ,loop ((,slicename ::ArrayList (ArrayList)) (,idx 0))
        ;(printf "idx: %s; overlap: %s; backamt: %s; groupsize: %s\n" ,idx ,overlap ,backamt ,groupsize)
        (cond
            ((>= (invoke ,slicename 'size) ,groupsize)
                ,@body
                (,loop (ArrayList) (- ,idx ,backamt))
            )
            ((not (>= ,idx (invoke ,source 'size)))
                (invoke ,slicename 'add (invoke ,source 'get ,idx))
                (,loop ,slicename (+ ,idx 1))
            )
        )
    ))
)

(define (divide-poly poly::polygon)
    (returning (polys::ArrayList[polygon] (ArrayList))
    (let* ((verts poly:verts)
           (size (ceiling (+ (/ (verts:size) 2) .5))))
        (with-overlapping-slices vertslice verts size 2
            ;(printf "%s %s\n" (verts:size) (vertslice:size))
            (if (>= (vertslice:size) 3)
                (polys:add (polygon vertslice))
            )
        )
    ))
)

(define (append-polygon-to-buffer old-buffer::FloatBuffer poly::polygon)
    (let* ((old-capacity (old-buffer:capacity))
           (floats-per-vertex 6)
           (old-vertcount (/ old-capacity floats-per-vertex))
           (sides (invoke poly:verts 'size))
           (total-new-floats::int (+ old-capacity (* floats-per-vertex sides)))
           (new-buffer (newDirectFloatBuffer total-new-floats))
        )
        (old-buffer:rewind)
        (new-buffer:put old-buffer)
        (java-iterate poly:verts (v vertex)
            (new-buffer:put v:x)
            (new-buffer:put v:y)
            (new-buffer:put v:z)

            (new-buffer:put v:r)
            (new-buffer:put v:g)
            (new-buffer:put v:b)
        )
        ; return the new buffer, and an (offset, size) pair for glDrawArrays to use for the new poly
        (values new-buffer (cons old-vertcount sides))
    )
)

(define *polygons-buffer* ::FloatBuffer (newDirectFloatBuffer 0))
(define (append-polygon-to-global-buffer poly::polygon)
    (let-values (((buf ind) (append-polygon-to-buffer *polygons-buffer* poly)))
        (set! *polygons-buffer* buf)
        ind
    )
)

(define *vbo-pointers* ::int[] (int[] length: 1))

(define (set-polygons-buffer gl2::GL2)
;    (*polygons-buffer*:rewind)
;    (gl2:glVertexPointer 3 gl2:GL_FLOAT 0 *polygons-buffer*)
    (gl2:glGenBuffers 1 *vbo-pointers* 0)
    (gl2:glBindBuffer gl2:GL_ARRAY_BUFFER (*vbo-pointers* 0))
    (*polygons-buffer*:rewind)
    (let ((tmp (float[] length: (*polygons-buffer*:capacity))))
        (*polygons-buffer*:get tmp)
        (display tmp) (newline)
    )
    (*polygons-buffer*:rewind)
    ; the multiplication by 4 is because glBufferData takes a size in bytes
    (gl2:glBufferData gl2:GL_ARRAY_BUFFER (* (*polygons-buffer*:capacity) 4) *polygons-buffer* gl2:GL_DYNAMIC_DRAW)
)

(define (shader-compiled? gl2::GL2 shader-id)
    (define tmp (int[] 0))
    (gl2:glGetShaderiv shader-id gl2:GL_COMPILE_STATUS tmp 0)
    (if (= (tmp 0) 0) #f #t)
)

(define (print-shader-info-log gl2::GL2 id::int)
    (define returned-size (int[] 0))
    (define len (let ((tmp (int[] 0))) (gl2:glGetShaderiv id gl2:GL_INFO_LOG_LENGTH tmp 0) (tmp 0)))
    (define data (byte[] length: len))
    (gl2:glGetShaderInfoLog id len returned-size 0 data 0)
    (if (> (returned-size 0) 0) (printf "ShaderInfoLog for shader %d: %s\n\n" id (String data)))
)

(define (glShaderSource gl2::GL2 id::int src::String)
    (gl2:glShaderSource id 1 (String[] src) (int[] (src:length)) 0)
)

(define (compile-shader gl2::GL2 type::int source::String)
    (returning (shader-id (gl2:glCreateShader type))
        ;(printf "shader source:\n%s\n\n" source)
        (glShaderSource gl2 shader-id source)
        (gl2:glCompileShader shader-id)
        (when (not (shader-compiled? gl2 shader-id))
            (print-shader-info-log gl2 shader-id)
            (error "Failed to compile shader.")
        )
    )
)

(define (make-shader-program gl2::GL2 vertex-source::String fragment-source::String)
    (returning (shader-program (gl2:glCreateProgram))
        (gl2:glAttachShader shader-program (compile-shader gl2 gl2:GL_VERTEX_SHADER vertex-source))
        (gl2:glAttachShader shader-program (compile-shader gl2 gl2:GL_FRAGMENT_SHADER fragment-source))
        (gl2:glLinkProgram shader-program)
    )
)

(define-alias PMVMatrix com.jogamp.opengl.util.PMVMatrix)
(define (getPMVMatrix gl2::GL2)
    (returning (mtrx (PMVMatrix))
        (define tmp (float[] length: 16))
        (gl2:glGetFloatv gl2:GL_MODELVIEW_MATRIX tmp 0)
        (gl2:glMatrixMode gl2:GL_MODELVIEW_MATRIX)
        (mtrx:glMatrixMode gl2:GL_MODELVIEW)
        (mtrx:glLoadMatrixf tmp 0)
        (gl2:glGetFloatv gl2:GL_PROJECTION_MATRIX tmp 0)
        (gl2:glMatrixMode gl2:GL_PROJECTION_MATRIX)
        (mtrx:glMatrixMode gl2:GL_PROJECTION)
        (mtrx:glLoadMatrixf tmp 0)
    )
)

(define-macro (aif/nn test then-clause #!optional (else-clause #!void))
    (define-gensyms tmp)
    `(let ((,tmp ,test))
        (if (not (equal? ,tmp #!null))
            (let ((it ,tmp)) ,then-clause)
            ,else-clause
        )
    )
)

(define (wpe-helper funcs forms)
    (letrec (
            (evaluatable? (lambda (form)
                ;(returning (tmp
                (if (pair? form)
                    (and (member (car form) funcs)
                         (fold (lambda (e a) (and a (evaluatable? e))) #t (cdr form))
                    )
                    (not (symbol? form))
                )
                ;) (display "in (evaluatable? ") (display form) (display "): ") (display tmp) (newline))
            ))
            (treewalk (lambda (replacer) (lambda (tree)
                ;(display "-----") (newline)
                ;(display tree) (newline)
                ;(display replacer) (newline)
                (aif/nn (replacer tree) it
                    (if (pair? tree)
                        (map (treewalk replacer) tree)
                        tree
                    )
                )
            )))
            (pe-replacer (lambda (tree)
                (if (evaluatable? tree)
                    (eval tree)
                    #!null
                )
            ))
        )
        (map (treewalk pe-replacer) forms)
    )
)
; getting some bytecode verify errors without this indirection, not quite sure why
(define-macro (with-partial-evaluation funcs . forms) (apply wpe-helper funcs forms))

; NOTE: uses 1d-arrays with column-major indexing, since this is to be used with openGL
(define-macro (ct-matrix-mult m n p elttype)
    (define arraytype `($bracket-apply$ ,elttype)) ; this depends on kawa internals, but the type system is already kawa-dependent
    (define (index row col height) (+ (* col height) row))
    (define (emit-matmult-expr r c)
        `(+ ,@(accumulate-range (i 0 n 1)
            `(* (mxn ,(index r i n)) (nxp ,(index i c p)))
        ))
    )
    `(lambda (mxn :: ,arraytype nxp :: ,arraytype)
        (,arraytype length: ,(* m p)
            ,@(with-list-collector col
                (pascal-for (c 0 p 1) (pascal-for (r 0 m 1)
                    (col (emit-matmult-expr r c))
                ))
            )
        )
    )
)

(define (untranslate/rotate ox oy rot px py)
    (define mtrx (PMVMatrix))
    (mtrx:glMatrixMode GL2:GL_MODELVIEW)
    (mtrx:glLoadIdentity)
    (mtrx:glTranslatef ox oy 0)
    (mtrx:glRotatef (rad->deg rot) 0 0 1)
    (define mvi-mtrx (mtrx:glGetMviMatrixf))
    (define m1 (float[] length: 16))
    (mtrx:update)
    (mvi-mtrx:reset)
    (mvi-mtrx:get m1)
    (define m2 (float[] px py 0 1))
    ((ct-matrix-mult 4 4 1 float) m1 m2)
)

(define (drawPolygon gl2::GL2 x y rot vertidx)
    (gl2:glMatrixMode gl2:GL_MODELVIEW)
    (gl2:glPushMatrix)
    (gl2:glTranslated x y 0)
    (gl2:glRotated (rad->deg rot) 0 0 1)
    (gl2:glDrawArrays gl2:GL_POLYGON (car vertidx) (cdr vertidx))
    (gl2:glPopMatrix)
)

) ; end of with-all-forms-exported
