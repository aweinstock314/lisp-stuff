(require 'list-lib)

(define-macro (with-all-forms-exported . forms)
    (letrec ((helper (lambda (form acc)
                (if (not (list? form)) acc
                (case (car form)
                    ((define-alias define-simple-class) (cons (cadr form) acc))
                    ((define define-constant define-macro)
                        (cons (cond
                            ((pair? (cadr form)) (caadr form))
                            ((symbol? (cadr form)) (cadr form))
                            (else (error "Unexpected type as the second element of a define form"))
                        ) acc)
                    )
                    (else acc)
                ))
            )))
        (define export-list (fold helper '() forms))
        (display "Automagically exporting the following from with-all-forms-exported: ") (newline)
        (display export-list) (newline)
        `(begin ,@forms ,@(if (not (null? export-list)) `((module-export ,@export-list)) '()))
    )
)
(module-export with-all-forms-exported)

(with-all-forms-exported

(define GL2 javax.media.opengl.GL2)
(define KeyEvent java.awt.event.KeyEvent)
(define printf java.lang.System:out:printf)
(define-alias ArrayList java.util.ArrayList)
(define-alias Number java.lang.Number)

(define-macro (thunk . body) `(lambda (. ,(gentemp)) ,@body))
(define-macro (mvbind vars expr . body) `(call-with-values (thunk ,expr) (lambda ,vars ,@body)))
(define-macro (mvlist expr) `(call-with-values (thunk ,expr) list))

; the first way has multiple-evaluation problems, but works fine for simple cases
; the second way (commented), should be the right way, but generates bytecode that gives verify errors unless extra annotations are done at the call site
(define-macro (inc! var delta)
    `(set! ,var (+ ,var ,delta))
    ;(let ((loc (gentemp))) `(let ((,loc (location ,var))) (set! (,loc) (+ (,loc) ,delta))))
)
(define-macro (inplace! fn var) `(set! ,var (,fn ,var)))

(define-macro (java-iterate iterable-expr varname . body)
    (define real-varname (if (list? varname) (car varname) varname))
    (define vartype (if (list? varname) (cadr varname) java.lang.Object))
    (define iterator-name (if (and (list? varname) (>= (length varname) 3)) (caddr varname) (gentemp)))
    `(let ((,iterator-name ::java.util.Iterator (invoke ,iterable-expr 'iterator))
           (,real-varname ::,vartype #!null))
        (do ()
            ((not (invoke ,iterator-name 'hasNext)) #!void)
            (set! ,real-varname (invoke ,iterator-name 'next))
            ,@body
        )
    )
)

(define-macro (pascal-for rng . body)
    (define var (car rng))
    (define lo (gentemp)) (define hi (gentemp)) (define step (gentemp))
    `(let ((,lo ,(cadr rng)) (,hi ,(caddr rng)) (,step ,(cadddr rng)))
        (do ((,var ,lo (+ ,var ,step)))
            ((= ,var ,hi) #!void)
            ,@body
        )
    )
)

(define-macro (accumulate-range rng . body)
    (define head (gentemp)) (define tail (gentemp))
    `(let* ((,head (cons '() '())) (,tail ,head))
        (pascal-for ,rng
            (set! (cdr ,tail) (cons (begin ,@body) (cdr ,tail)))
            (inplace! cdr ,tail)
        )
        (cdr ,head)
    )
)

(define-macro (curry expr)
    (define argsname (gentemp))
    `(lambda (. ,argsname) (apply ,@expr ,argsname))
)
(define (complement pred) (lambda (. args) (not (apply pred args))))

(define (upto x) (do ((i 0 (+ i 1)) (acc '() (cons i acc))) ((= i x) (reverse! acc))))
(define (clamp lo hi) (lambda (val) (max lo (min hi val))))
(define (wrap lo hi) (lambda (val)
    (cond ((< val lo) hi)
          ((> val hi) lo)
          (else val)
    )
))
(define (within? lo hi) (lambda (val::Number)::boolean (<= lo val hi)))

(define (constantly x) (lambda (. args) x))
(define tau (* 8 (atan 1)))
(define atan2 java.lang.Math:atan2)
(define (rad->deg r) (/ (* r 360) tau))
(define (random x) (* x (java.lang.Math:random)))
(define (random-range lo hi) (+ lo (* (- hi lo) (java.lang.Math:random))))

(define-simple-class vertex ()
    (x::double 0) (y::double 0)
    ((*init*) #!void)
    ((*init* ix::double iy::double)
        (set! x ix)
        (set! y iy)
    )
    ((toString)::String (String:format "c(%f, %f)" x y))
)

(define-simple-class polar-vertex ()
    (m::double 0) (t::double 0)
    ((*init*) #!void)
    ((*init* im::double it::double)
        (set! m im)
        (set! t it)
    )
    ((toString)::String (String:format "p(%f, %f)" m t))
)

(define (cart->polar v::vertex) (polar-vertex (sqrt (+ (square v:x) (square v:y))) (atan2 v:y v:x)))
(define (polar->cart p::polar-vertex) (vertex (* p:m (cos p:t)) (* p:m (sin p:t))))
(define (cart+ v1::vertex v2::vertex) (vertex (+ v1:x v2:x) (+ v1:y v2:y)))

; returns a list of vertices of a "regular" polygon, with the first vertex at rot radians
; the radius parameter is a function to allow non-regular polygons such as isosceles triangles
(define (calc-poly rot::double radiusf::gnu.mapping.Procedure sides::int)
    (accumulate-range (i 0 sides 1)
        (let* ((rad::double (radiusf i))
               (ang::double (+ rot (* tau (/ i sides))))
               (vx::double (* rad (cos ang)))
               (vy::double (* rad (sin ang)))
            )
            (vertex vx vy)
        )
    )
)

(define (drawPolygon gl2::GL2 x y rot color verts)
    (gl2:glMatrixMode gl2:GL_MODELVIEW)
    (gl2:glPushMatrix)
    (gl2:glLoadIdentity)
    (gl2:glTranslated x y 0)
    (gl2:glRotated (rad->deg rot) 0 0 1)
    (gl2:glBegin gl2:GL_POLYGON)
    (apply gl2:glColor3d color)
    (for-each (lambda (v::vertex)
        (gl2:glVertex2d v:x v:y)
    ) verts)
    (gl2:glEnd)
    (gl2:glPopMatrix)
)

) ; end of with-all-forms-exported
