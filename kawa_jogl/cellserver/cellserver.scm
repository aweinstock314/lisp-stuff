(require <scheme_util_general>)
(require 'regex)

(java-imports (com.sun.net.httpserver HttpServer HttpExchange)
              (java.io PrintStream)
              (java.net InetSocketAddress)
)

(define (serve-string e::HttpExchange code::int str::String)
    (e:sendResponseHeaders code (str:length))
    (define ps (PrintStream (e:getResponseBody)))
    (ps:print str)
    (ps:close)
)

(define (extract-parameters requestPath::String)
    (regex-match #/^\/rule([0-9]+)seed([0-9a-fA-F]+)$/ requestPath)
)

(define (emit-page bodycontent)
    (define titlestr "Cellserver - dynamically serving 1d cellular automata")
    (html:html (html:head (html:title titlestr)) (html:body bodycontent))
)

(define (bitvector-of-int x::integer)
    (returning (vec (make-u8vector (bitwise-length x)))
        (pascal-for (i 0 (bitwise-length x) 1)
            (u8vector-set! vec i (if (bitwise-bit-set? x i) 1 0))
        )
    )
)

; this can probably be done more efficiently without intermediate lists
(define (u8vector-concat . vecs) (list->u8vector (apply append (map u8vector->list vecs))))

(define (ensure-minimum-length vec::u8vector n)
    (define padding (make-u8vector (- n (u8vector-length vec))))
    (u8vector-concat vec padding)
)

(define (intersperse-spacing vec n)
    (returning (newvec (make-u8vector (* (+ n 1) (u8vector-length vec))))
        (pascal-for (i 0 (u8vector-length vec) 1)
            (set! (newvec (* i (+ n 1))) (vec i))
        )
    )
)

(define (table-row-of-bitvector vec::u8vector)
    (apply html:tr (accumulate-range (i 0 (u8vector-length vec) 1)
        (cond ((or (= (vec i) 0) (= (vec i) 1))
                (define color (String[]  "#000000" "#ffffff"))
                (define style (String:format "{color: %s; background-color: %s;}" (color (vec i)) (color (- 1 (vec i)))))
                (unescaped-data (String:format "<td style=\"%s\">%s</td>" style (vec i)))
            )
            (#t (html:td))
        )
    ))
)

(define (table-of-bitvector-list lst)
    (apply html:table border: 1 style: "{display: inline-table;}" (map table-row-of-bitvector lst))
)

(define (make-rules-table rulenum)
    (define (make-rule-cell idx val)
        (table-of-bitvector-list (list (ensure-minimum-length (bitvector-of-int idx) 3) (u8vector -1 val -1)))
    )
    (define rulevec (ensure-minimum-length (bitvector-of-int rulenum) 8))
    (apply html:div "Rewrite rules: " (html:br)
        (do ((i 0 (+ i 1))
            (acc '() (cons (make-rule-cell i (rulevec i)) acc)))
            ((= i 8) (reverse acc))
        )
    )
)

(define (valid-response e::HttpExchange match)
    (let* ( (rulestr (match 1)) (seedstr (match 2))
            (rulenode (list "Rule:" rulestr (html:br)))
            (seednode (list (String:format "Seed: 0x%s" seedstr) (html:br)))
            (rulenum (Integer:valueOf rulestr 10))
            (seednum (Integer:valueOf seedstr 16))
            ;(sometable (list (table-of-bitvector-list (accumulate-range (i 1 100 1) (ensure-minimum-length (bitvector-of-int i) 10)))))
            (sometable (list (make-rules-table rulenum)))
        )
        (apply html:span (append rulenode seednode sometable))
    )
)

(define (invalid-response e::HttpExchange)
    (html:span "Invalid Parameters - try page " (html:a href: #1="/rule30seed1" #1#) (html:br))
)

(define-macro (handle-request-form) '(lambda (e::HttpExchange)
    (print-exceptions
        (printf "Handling a request to %s\n" (e:getRemoteAddress))
        (define requestPath ((e:getRequestURI):getPath))
        (printf "Request URI: \"%s\"\n" requestPath)
        (define parameters-match (extract-parameters requestPath))
        (define bodycontent (if parameters-match (valid-response e parameters-match) (invalid-response e)))
        (serve-string e 200 (emit-page bodycontent)) ; maybe change the code for an invalid response?
        (e:close)
    )
))

(define port-number 8100)

(define serv (HttpServer:create (InetSocketAddress port-number) -1))
(serv:start)
(serv:createContext "/" (handle-request-form))
(printf "Bound to port %s\n" port-number)
