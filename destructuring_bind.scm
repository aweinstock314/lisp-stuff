(define (foldl fn lst acc)
    (if (null? lst) acc
        (foldl fn (cdr lst) (fn acc (car lst)))
    )
)

; (make-cxr '(a d)) acts like cadr
(define (make-cxr path)
    (lambda (lst)
        (foldl (lambda (acc elem)
            (cond ((eqv? elem 'a) (car acc))
                  ((eqv? elem 'd) (cdr acc))
                  (else (error "element of path was not an a or d"))
            )
        ) (reverse path) lst)
    )
)

(define (replace-leaves-with-getters tree)
    (letrec ((aux (lambda (subtree path)
                (cond ((null? subtree) '())
                      ((pair? subtree) (cons
                          (aux (car subtree) (cons 'a path))
                          (aux (cdr subtree) (cons 'd path))
                      ))
                      (else (make-cxr path))
                )
            )))
        (aux tree '())
    )
)

(define (flatten-tree tree)
    (if (pair? tree)
        (apply append (map flatten-tree tree))
        (list tree)
    )
)
;; example fragment:
;(define x '(((a) b) c (d e)))
;(define xgetters (flatten-tree (replace-leaves-with-getters x)))
;(map (lambda (f) (f x)) xgetters)


(define (destructuring-bind-runtime pattern val fn)
    (let* ((getters (flatten-tree (replace-leaves-with-getters pattern))))
        (apply fn (map (lambda (getter) (getter val)) getters))
    )
)

; example: (destructuring-bind-runtime '((a) b) '((1) 2) (lambda (a b) (list a b)))

(define (destructuring-bind-expander pattern val . body)
    (define (make-cxr-code path)
       (define (make-accessor sym)
            (cond ((eqv? sym 'a) 'car)
                  ((eqv? sym 'd) 'cdr)
                  (else (error "element of path was not an a or d"))
            )
        )
        (define (step-expander path-remainder)
            (if (null? path-remainder)
                `(lambda (x) x)
                `(lambda (lst)
                    (if (pair? lst)
                        (,(step-expander (cdr path-remainder)) (,(make-accessor (car path-remainder)) lst))
                        (error "no cxr")
                    )
                )
            )
        )
        (step-expander (reverse path))
    )
    (define (replace-leaves-with-getters tree)
        (letrec ((aux (lambda (subtree path)
                    (cond ((null? subtree) '())
                          ((pair? subtree) (cons
                              (aux (car subtree) (cons 'a path))
                              (aux (cdr subtree) (cons 'd path))
                          ))
                          ; delay evaluation so that flatten-tree doesn't work on the code returned
                          (else (lambda () (make-cxr-code path)))
                    )
                )))
            (aux tree '())
        )
    )
    (define (flatten-tree tree)
        (if (pair? tree)
            (apply append (map flatten-tree tree))
            (list tree)
        )
    )
    (define varnames (flatten-tree pattern))
    (define getters (map (lambda (f) (f)) (flatten-tree (replace-leaves-with-getters pattern))))
    (define oo-val (gentemp))
    `(let* ((,oo-val ,val) ,@(map (lambda (var get) `(,var (,get ,oo-val)))  varnames getters))
        ,@body
    )
)

; define-macro isn't r5rs, but I wasn't able to find a good source on define-syntax/syntax-rules/syntax-case
(define-macro destructuring-bind destructuring-bind-expander)

; example: (destructuring-bind ((a) b) '((1) 2) (list a b))
